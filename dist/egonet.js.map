{"version":3,"file":"egonet.js","sources":["../https:/deno.land/std@0.74.0/encoding/utf8.ts","../https:/deno.land/std@0.74.0/bytes/mod.ts","../https:/deno.land/std@0.74.0/_util/assert.ts","../https:/deno.land/std@0.74.0/io/bufio.ts","../https:/deno.land/std@0.74.0/async/deferred.ts","../https:/deno.land/std@0.74.0/async/mux_async_iterator.ts","../https:/deno.land/std@0.74.0/textproto/mod.ts","../https:/deno.land/std@0.74.0/http/http_status.ts","../https:/deno.land/std@0.74.0/http/_io.ts","../https:/deno.land/std@0.74.0/http/server.ts","../https:/dev.jspm.io/npm:ngraph.events@1.2.1/index.dew.js","../https:/dev.jspm.io/npm:ngraph.graph@19.1.0/index.dew.js","../https:/dev.jspm.io/ngraph.graph","../file:/Users/U715864/egonet/ego-network/src/egograph.ts","../file:/Users/U715864/egonet/ego-network/src/egonet.ts"],"sourcesContent":["// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n\n/** A default TextEncoder instance */\nexport const encoder = new TextEncoder();\n\n/** Shorthand for new TextEncoder().encode() */\nexport function encode(input?: string): Uint8Array {\n  return encoder.encode(input);\n}\n\n/** A default TextDecoder instance */\nexport const decoder = new TextDecoder();\n\n/** Shorthand for new TextDecoder().decode() */\nexport function decode(input?: Uint8Array): string {\n  return decoder.decode(input);\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n\n/** Find first index of binary pattern from a. If not found, then return -1\n * @param source source array\n * @param pat pattern to find in source array\n */\nexport function findIndex(source: Uint8Array, pat: Uint8Array): number {\n  const s = pat[0];\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] !== s) continue;\n    const pin = i;\n    let matched = 1;\n    let j = i;\n    while (matched < pat.length) {\n      j++;\n      if (source[j] !== pat[j - pin]) {\n        break;\n      }\n      matched++;\n    }\n    if (matched === pat.length) {\n      return pin;\n    }\n  }\n  return -1;\n}\n\n/** Find last index of binary pattern from a. If not found, then return -1.\n * @param source source array\n * @param pat pattern to find in source array\n */\nexport function findLastIndex(source: Uint8Array, pat: Uint8Array): number {\n  const e = pat[pat.length - 1];\n  for (let i = source.length - 1; i >= 0; i--) {\n    if (source[i] !== e) continue;\n    const pin = i;\n    let matched = 1;\n    let j = i;\n    while (matched < pat.length) {\n      j--;\n      if (source[j] !== pat[pat.length - 1 - (pin - j)]) {\n        break;\n      }\n      matched++;\n    }\n    if (matched === pat.length) {\n      return pin - pat.length + 1;\n    }\n  }\n  return -1;\n}\n\n/** Check whether binary arrays are equal to each other.\n * @param source first array to check equality\n * @param match second array to check equality\n */\nexport function equal(source: Uint8Array, match: Uint8Array): boolean {\n  if (source.length !== match.length) return false;\n  for (let i = 0; i < match.length; i++) {\n    if (source[i] !== match[i]) return false;\n  }\n  return true;\n}\n\n/** Check whether binary array starts with prefix.\n * @param source srouce array\n * @param prefix prefix array to check in source\n */\nexport function hasPrefix(source: Uint8Array, prefix: Uint8Array): boolean {\n  for (let i = 0, max = prefix.length; i < max; i++) {\n    if (source[i] !== prefix[i]) return false;\n  }\n  return true;\n}\n\n/** Check whether binary array ends with suffix.\n * @param source source array\n * @param suffix suffix array to check in source\n */\nexport function hasSuffix(source: Uint8Array, suffix: Uint8Array): boolean {\n  for (\n    let srci = source.length - 1, sfxi = suffix.length - 1;\n    sfxi >= 0;\n    srci--, sfxi--\n  ) {\n    if (source[srci] !== suffix[sfxi]) return false;\n  }\n  return true;\n}\n\n/** Repeat bytes. returns a new byte slice consisting of `count` copies of `b`.\n * @param origin The origin bytes\n * @param count The count you want to repeat.\n */\nexport function repeat(origin: Uint8Array, count: number): Uint8Array {\n  if (count === 0) {\n    return new Uint8Array();\n  }\n\n  if (count < 0) {\n    throw new Error(\"bytes: negative repeat count\");\n  } else if ((origin.length * count) / count !== origin.length) {\n    throw new Error(\"bytes: repeat count causes overflow\");\n  }\n\n  const int = Math.floor(count);\n\n  if (int !== count) {\n    throw new Error(\"bytes: repeat count must be an integer\");\n  }\n\n  const nb = new Uint8Array(origin.length * count);\n\n  let bp = copyBytes(origin, nb);\n\n  for (; bp < nb.length; bp *= 2) {\n    copyBytes(nb.slice(0, bp), nb, bp);\n  }\n\n  return nb;\n}\n\n/** Concatenate two binary arrays and return new one.\n * @param origin origin array to concatenate\n * @param b array to concatenate with origin\n */\nexport function concat(origin: Uint8Array, b: Uint8Array): Uint8Array {\n  const output = new Uint8Array(origin.length + b.length);\n  output.set(origin, 0);\n  output.set(b, origin.length);\n  return output;\n}\n\n/** Check source array contains pattern array.\n * @param source source array\n * @param pat patter array\n */\nexport function contains(source: Uint8Array, pat: Uint8Array): boolean {\n  return findIndex(source, pat) != -1;\n}\n\n/**\n * Copy bytes from one Uint8Array to another.  Bytes from `src` which don't fit\n * into `dst` will not be copied.\n *\n * @param src Source byte array\n * @param dst Destination byte array\n * @param off Offset into `dst` at which to begin writing values from `src`.\n * @return number of bytes copied\n */\nexport function copyBytes(src: Uint8Array, dst: Uint8Array, off = 0): number {\n  off = Math.max(0, Math.min(off, dst.byteLength));\n  const dstBytesAvailable = dst.byteLength - off;\n  if (src.byteLength > dstBytesAvailable) {\n    src = src.subarray(0, dstBytesAvailable);\n  }\n  dst.set(src, off);\n  return src.byteLength;\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n\nexport class DenoStdInternalError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"DenoStdInternalError\";\n  }\n}\n\n/** Make an assertion, if not `true`, then throw. */\nexport function assert(expr: unknown, msg = \"\"): asserts expr {\n  if (!expr) {\n    throw new DenoStdInternalError(msg);\n  }\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n// Based on https://github.com/golang/go/blob/891682/src/bufio/bufio.go\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\ntype Reader = Deno.Reader;\ntype Writer = Deno.Writer;\ntype WriterSync = Deno.WriterSync;\nimport { copyBytes } from \"../bytes/mod.ts\";\nimport { assert } from \"../_util/assert.ts\";\n\nconst DEFAULT_BUF_SIZE = 4096;\nconst MIN_BUF_SIZE = 16;\nconst MAX_CONSECUTIVE_EMPTY_READS = 100;\nconst CR = \"\\r\".charCodeAt(0);\nconst LF = \"\\n\".charCodeAt(0);\n\nexport class BufferFullError extends Error {\n  name = \"BufferFullError\";\n  constructor(public partial: Uint8Array) {\n    super(\"Buffer full\");\n  }\n}\n\nexport class PartialReadError extends Deno.errors.UnexpectedEof {\n  name = \"PartialReadError\";\n  partial?: Uint8Array;\n  constructor() {\n    super(\"Encountered UnexpectedEof, data only partially read\");\n  }\n}\n\n/** Result type returned by of BufReader.readLine(). */\nexport interface ReadLineResult {\n  line: Uint8Array;\n  more: boolean;\n}\n\n/** BufReader implements buffering for a Reader object. */\nexport class BufReader implements Reader {\n  private buf!: Uint8Array;\n  private rd!: Reader; // Reader provided by caller.\n  private r = 0; // buf read position.\n  private w = 0; // buf write position.\n  private eof = false;\n  // private lastByte: number;\n  // private lastCharSize: number;\n\n  /** return new BufReader unless r is BufReader */\n  static create(r: Reader, size: number = DEFAULT_BUF_SIZE): BufReader {\n    return r instanceof BufReader ? r : new BufReader(r, size);\n  }\n\n  constructor(rd: Reader, size: number = DEFAULT_BUF_SIZE) {\n    if (size < MIN_BUF_SIZE) {\n      size = MIN_BUF_SIZE;\n    }\n    this._reset(new Uint8Array(size), rd);\n  }\n\n  /** Returns the size of the underlying buffer in bytes. */\n  size(): number {\n    return this.buf.byteLength;\n  }\n\n  buffered(): number {\n    return this.w - this.r;\n  }\n\n  // Reads a new chunk into the buffer.\n  private async _fill(): Promise<void> {\n    // Slide existing data to beginning.\n    if (this.r > 0) {\n      this.buf.copyWithin(0, this.r, this.w);\n      this.w -= this.r;\n      this.r = 0;\n    }\n\n    if (this.w >= this.buf.byteLength) {\n      throw Error(\"bufio: tried to fill full buffer\");\n    }\n\n    // Read new data: try a limited number of times.\n    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {\n      const rr = await this.rd.read(this.buf.subarray(this.w));\n      if (rr === null) {\n        this.eof = true;\n        return;\n      }\n      assert(rr >= 0, \"negative read\");\n      this.w += rr;\n      if (rr > 0) {\n        return;\n      }\n    }\n\n    throw new Error(\n      `No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`,\n    );\n  }\n\n  /** Discards any buffered data, resets all state, and switches\n   * the buffered reader to read from r.\n   */\n  reset(r: Reader): void {\n    this._reset(this.buf, r);\n  }\n\n  private _reset(buf: Uint8Array, rd: Reader): void {\n    this.buf = buf;\n    this.rd = rd;\n    this.eof = false;\n    // this.lastByte = -1;\n    // this.lastCharSize = -1;\n  }\n\n  /** reads data into p.\n   * It returns the number of bytes read into p.\n   * The bytes are taken from at most one Read on the underlying Reader,\n   * hence n may be less than len(p).\n   * To read exactly len(p) bytes, use io.ReadFull(b, p).\n   */\n  async read(p: Uint8Array): Promise<number | null> {\n    let rr: number | null = p.byteLength;\n    if (p.byteLength === 0) return rr;\n\n    if (this.r === this.w) {\n      if (p.byteLength >= this.buf.byteLength) {\n        // Large read, empty buffer.\n        // Read directly into p to avoid copy.\n        const rr = await this.rd.read(p);\n        const nread = rr ?? 0;\n        assert(nread >= 0, \"negative read\");\n        // if (rr.nread > 0) {\n        //   this.lastByte = p[rr.nread - 1];\n        //   this.lastCharSize = -1;\n        // }\n        return rr;\n      }\n\n      // One read.\n      // Do not use this.fill, which will loop.\n      this.r = 0;\n      this.w = 0;\n      rr = await this.rd.read(this.buf);\n      if (rr === 0 || rr === null) return rr;\n      assert(rr >= 0, \"negative read\");\n      this.w += rr;\n    }\n\n    // copy as much as we can\n    const copied = copyBytes(this.buf.subarray(this.r, this.w), p, 0);\n    this.r += copied;\n    // this.lastByte = this.buf[this.r - 1];\n    // this.lastCharSize = -1;\n    return copied;\n  }\n\n  /** reads exactly `p.length` bytes into `p`.\n   *\n   * If successful, `p` is returned.\n   *\n   * If the end of the underlying stream has been reached, and there are no more\n   * bytes available in the buffer, `readFull()` returns `null` instead.\n   *\n   * An error is thrown if some bytes could be read, but not enough to fill `p`\n   * entirely before the underlying stream reported an error or EOF. Any error\n   * thrown will have a `partial` property that indicates the slice of the\n   * buffer that has been successfully filled with data.\n   *\n   * Ported from https://golang.org/pkg/io/#ReadFull\n   */\n  async readFull(p: Uint8Array): Promise<Uint8Array | null> {\n    let bytesRead = 0;\n    while (bytesRead < p.length) {\n      try {\n        const rr = await this.read(p.subarray(bytesRead));\n        if (rr === null) {\n          if (bytesRead === 0) {\n            return null;\n          } else {\n            throw new PartialReadError();\n          }\n        }\n        bytesRead += rr;\n      } catch (err) {\n        err.partial = p.subarray(0, bytesRead);\n        throw err;\n      }\n    }\n    return p;\n  }\n\n  /** Returns the next byte [0, 255] or `null`. */\n  async readByte(): Promise<number | null> {\n    while (this.r === this.w) {\n      if (this.eof) return null;\n      await this._fill(); // buffer is empty.\n    }\n    const c = this.buf[this.r];\n    this.r++;\n    // this.lastByte = c;\n    return c;\n  }\n\n  /** readString() reads until the first occurrence of delim in the input,\n   * returning a string containing the data up to and including the delimiter.\n   * If ReadString encounters an error before finding a delimiter,\n   * it returns the data read before the error and the error itself\n   * (often `null`).\n   * ReadString returns err != nil if and only if the returned data does not end\n   * in delim.\n   * For simple uses, a Scanner may be more convenient.\n   */\n  async readString(delim: string): Promise<string | null> {\n    if (delim.length !== 1) {\n      throw new Error(\"Delimiter should be a single character\");\n    }\n    const buffer = await this.readSlice(delim.charCodeAt(0));\n    if (buffer === null) return null;\n    return new TextDecoder().decode(buffer);\n  }\n\n  /** `readLine()` is a low-level line-reading primitive. Most callers should\n   * use `readString('\\n')` instead or use a Scanner.\n   *\n   * `readLine()` tries to return a single line, not including the end-of-line\n   * bytes. If the line was too long for the buffer then `more` is set and the\n   * beginning of the line is returned. The rest of the line will be returned\n   * from future calls. `more` will be false when returning the last fragment\n   * of the line. The returned buffer is only valid until the next call to\n   * `readLine()`.\n   *\n   * The text returned from ReadLine does not include the line end (\"\\r\\n\" or\n   * \"\\n\").\n   *\n   * When the end of the underlying stream is reached, the final bytes in the\n   * stream are returned. No indication or error is given if the input ends\n   * without a final line end. When there are no more trailing bytes to read,\n   * `readLine()` returns `null`.\n   *\n   * Calling `unreadByte()` after `readLine()` will always unread the last byte\n   * read (possibly a character belonging to the line end) even if that byte is\n   * not part of the line returned by `readLine()`.\n   */\n  async readLine(): Promise<ReadLineResult | null> {\n    let line: Uint8Array | null;\n\n    try {\n      line = await this.readSlice(LF);\n    } catch (err) {\n      let { partial } = err;\n      assert(\n        partial instanceof Uint8Array,\n        \"bufio: caught error from `readSlice()` without `partial` property\",\n      );\n\n      // Don't throw if `readSlice()` failed with `BufferFullError`, instead we\n      // just return whatever is available and set the `more` flag.\n      if (!(err instanceof BufferFullError)) {\n        throw err;\n      }\n\n      // Handle the case where \"\\r\\n\" straddles the buffer.\n      if (\n        !this.eof &&\n        partial.byteLength > 0 &&\n        partial[partial.byteLength - 1] === CR\n      ) {\n        // Put the '\\r' back on buf and drop it from line.\n        // Let the next call to ReadLine check for \"\\r\\n\".\n        assert(this.r > 0, \"bufio: tried to rewind past start of buffer\");\n        this.r--;\n        partial = partial.subarray(0, partial.byteLength - 1);\n      }\n\n      return { line: partial, more: !this.eof };\n    }\n\n    if (line === null) {\n      return null;\n    }\n\n    if (line.byteLength === 0) {\n      return { line, more: false };\n    }\n\n    if (line[line.byteLength - 1] == LF) {\n      let drop = 1;\n      if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {\n        drop = 2;\n      }\n      line = line.subarray(0, line.byteLength - drop);\n    }\n    return { line, more: false };\n  }\n\n  /** `readSlice()` reads until the first occurrence of `delim` in the input,\n   * returning a slice pointing at the bytes in the buffer. The bytes stop\n   * being valid at the next read.\n   *\n   * If `readSlice()` encounters an error before finding a delimiter, or the\n   * buffer fills without finding a delimiter, it throws an error with a\n   * `partial` property that contains the entire buffer.\n   *\n   * If `readSlice()` encounters the end of the underlying stream and there are\n   * any bytes left in the buffer, the rest of the buffer is returned. In other\n   * words, EOF is always treated as a delimiter. Once the buffer is empty,\n   * it returns `null`.\n   *\n   * Because the data returned from `readSlice()` will be overwritten by the\n   * next I/O operation, most clients should use `readString()` instead.\n   */\n  async readSlice(delim: number): Promise<Uint8Array | null> {\n    let s = 0; // search start index\n    let slice: Uint8Array | undefined;\n\n    while (true) {\n      // Search buffer.\n      let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);\n      if (i >= 0) {\n        i += s;\n        slice = this.buf.subarray(this.r, this.r + i + 1);\n        this.r += i + 1;\n        break;\n      }\n\n      // EOF?\n      if (this.eof) {\n        if (this.r === this.w) {\n          return null;\n        }\n        slice = this.buf.subarray(this.r, this.w);\n        this.r = this.w;\n        break;\n      }\n\n      // Buffer full?\n      if (this.buffered() >= this.buf.byteLength) {\n        this.r = this.w;\n        // #4521 The internal buffer should not be reused across reads because it causes corruption of data.\n        const oldbuf = this.buf;\n        const newbuf = this.buf.slice(0);\n        this.buf = newbuf;\n        throw new BufferFullError(oldbuf);\n      }\n\n      s = this.w - this.r; // do not rescan area we scanned before\n\n      // Buffer is not full.\n      try {\n        await this._fill();\n      } catch (err) {\n        err.partial = slice;\n        throw err;\n      }\n    }\n\n    // Handle last byte, if any.\n    // const i = slice.byteLength - 1;\n    // if (i >= 0) {\n    //   this.lastByte = slice[i];\n    //   this.lastCharSize = -1\n    // }\n\n    return slice;\n  }\n\n  /** `peek()` returns the next `n` bytes without advancing the reader. The\n   * bytes stop being valid at the next read call.\n   *\n   * When the end of the underlying stream is reached, but there are unread\n   * bytes left in the buffer, those bytes are returned. If there are no bytes\n   * left in the buffer, it returns `null`.\n   *\n   * If an error is encountered before `n` bytes are available, `peek()` throws\n   * an error with the `partial` property set to a slice of the buffer that\n   * contains the bytes that were available before the error occurred.\n   */\n  async peek(n: number): Promise<Uint8Array | null> {\n    if (n < 0) {\n      throw Error(\"negative count\");\n    }\n\n    let avail = this.w - this.r;\n    while (avail < n && avail < this.buf.byteLength && !this.eof) {\n      try {\n        await this._fill();\n      } catch (err) {\n        err.partial = this.buf.subarray(this.r, this.w);\n        throw err;\n      }\n      avail = this.w - this.r;\n    }\n\n    if (avail === 0 && this.eof) {\n      return null;\n    } else if (avail < n && this.eof) {\n      return this.buf.subarray(this.r, this.r + avail);\n    } else if (avail < n) {\n      throw new BufferFullError(this.buf.subarray(this.r, this.w));\n    }\n\n    return this.buf.subarray(this.r, this.r + n);\n  }\n}\n\nabstract class AbstractBufBase {\n  buf!: Uint8Array;\n  usedBufferBytes = 0;\n  err: Error | null = null;\n\n  /** Size returns the size of the underlying buffer in bytes. */\n  size(): number {\n    return this.buf.byteLength;\n  }\n\n  /** Returns how many bytes are unused in the buffer. */\n  available(): number {\n    return this.buf.byteLength - this.usedBufferBytes;\n  }\n\n  /** buffered returns the number of bytes that have been written into the\n   * current buffer.\n   */\n  buffered(): number {\n    return this.usedBufferBytes;\n  }\n}\n\n/** BufWriter implements buffering for an deno.Writer object.\n * If an error occurs writing to a Writer, no more data will be\n * accepted and all subsequent writes, and flush(), will return the error.\n * After all data has been written, the client should call the\n * flush() method to guarantee all data has been forwarded to\n * the underlying deno.Writer.\n */\nexport class BufWriter extends AbstractBufBase implements Writer {\n  /** return new BufWriter unless writer is BufWriter */\n  static create(writer: Writer, size: number = DEFAULT_BUF_SIZE): BufWriter {\n    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);\n  }\n\n  constructor(private writer: Writer, size: number = DEFAULT_BUF_SIZE) {\n    super();\n    if (size <= 0) {\n      size = DEFAULT_BUF_SIZE;\n    }\n    this.buf = new Uint8Array(size);\n  }\n\n  /** Discards any unflushed buffered data, clears any error, and\n   * resets buffer to write its output to w.\n   */\n  reset(w: Writer): void {\n    this.err = null;\n    this.usedBufferBytes = 0;\n    this.writer = w;\n  }\n\n  /** Flush writes any buffered data to the underlying io.Writer. */\n  async flush(): Promise<void> {\n    if (this.err !== null) throw this.err;\n    if (this.usedBufferBytes === 0) return;\n\n    try {\n      await Deno.writeAll(\n        this.writer,\n        this.buf.subarray(0, this.usedBufferBytes),\n      );\n    } catch (e) {\n      this.err = e;\n      throw e;\n    }\n\n    this.buf = new Uint8Array(this.buf.length);\n    this.usedBufferBytes = 0;\n  }\n\n  /** Writes the contents of `data` into the buffer.  If the contents won't fully\n   * fit into the buffer, those bytes that can are copied into the buffer, the\n   * buffer is the flushed to the writer and the remaining bytes are copied into\n   * the now empty buffer.\n   *\n   * @return the number of bytes written to the buffer.\n   */\n  async write(data: Uint8Array): Promise<number> {\n    if (this.err !== null) throw this.err;\n    if (data.length === 0) return 0;\n\n    let totalBytesWritten = 0;\n    let numBytesWritten = 0;\n    while (data.byteLength > this.available()) {\n      if (this.buffered() === 0) {\n        // Large write, empty buffer.\n        // Write directly from data to avoid copy.\n        try {\n          numBytesWritten = await this.writer.write(data);\n        } catch (e) {\n          this.err = e;\n          throw e;\n        }\n      } else {\n        numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);\n        this.usedBufferBytes += numBytesWritten;\n        await this.flush();\n      }\n      totalBytesWritten += numBytesWritten;\n      data = data.subarray(numBytesWritten);\n    }\n\n    numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);\n    this.usedBufferBytes += numBytesWritten;\n    totalBytesWritten += numBytesWritten;\n    return totalBytesWritten;\n  }\n}\n\n/** BufWriterSync implements buffering for a deno.WriterSync object.\n * If an error occurs writing to a WriterSync, no more data will be\n * accepted and all subsequent writes, and flush(), will return the error.\n * After all data has been written, the client should call the\n * flush() method to guarantee all data has been forwarded to\n * the underlying deno.WriterSync.\n */\nexport class BufWriterSync extends AbstractBufBase implements WriterSync {\n  /** return new BufWriterSync unless writer is BufWriterSync */\n  static create(\n    writer: WriterSync,\n    size: number = DEFAULT_BUF_SIZE,\n  ): BufWriterSync {\n    return writer instanceof BufWriterSync\n      ? writer\n      : new BufWriterSync(writer, size);\n  }\n\n  constructor(private writer: WriterSync, size: number = DEFAULT_BUF_SIZE) {\n    super();\n    if (size <= 0) {\n      size = DEFAULT_BUF_SIZE;\n    }\n    this.buf = new Uint8Array(size);\n  }\n\n  /** Discards any unflushed buffered data, clears any error, and\n   * resets buffer to write its output to w.\n   */\n  reset(w: WriterSync): void {\n    this.err = null;\n    this.usedBufferBytes = 0;\n    this.writer = w;\n  }\n\n  /** Flush writes any buffered data to the underlying io.WriterSync. */\n  flush(): void {\n    if (this.err !== null) throw this.err;\n    if (this.usedBufferBytes === 0) return;\n\n    try {\n      Deno.writeAllSync(\n        this.writer,\n        this.buf.subarray(0, this.usedBufferBytes),\n      );\n    } catch (e) {\n      this.err = e;\n      throw e;\n    }\n\n    this.buf = new Uint8Array(this.buf.length);\n    this.usedBufferBytes = 0;\n  }\n\n  /** Writes the contents of `data` into the buffer.  If the contents won't fully\n   * fit into the buffer, those bytes that can are copied into the buffer, the\n   * buffer is the flushed to the writer and the remaining bytes are copied into\n   * the now empty buffer.\n   *\n   * @return the number of bytes written to the buffer.\n   */\n  writeSync(data: Uint8Array): number {\n    if (this.err !== null) throw this.err;\n    if (data.length === 0) return 0;\n\n    let totalBytesWritten = 0;\n    let numBytesWritten = 0;\n    while (data.byteLength > this.available()) {\n      if (this.buffered() === 0) {\n        // Large write, empty buffer.\n        // Write directly from data to avoid copy.\n        try {\n          numBytesWritten = this.writer.writeSync(data);\n        } catch (e) {\n          this.err = e;\n          throw e;\n        }\n      } else {\n        numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);\n        this.usedBufferBytes += numBytesWritten;\n        this.flush();\n      }\n      totalBytesWritten += numBytesWritten;\n      data = data.subarray(numBytesWritten);\n    }\n\n    numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);\n    this.usedBufferBytes += numBytesWritten;\n    totalBytesWritten += numBytesWritten;\n    return totalBytesWritten;\n  }\n}\n\n/** Generate longest proper prefix which is also suffix array. */\nfunction createLPS(pat: Uint8Array): Uint8Array {\n  const lps = new Uint8Array(pat.length);\n  lps[0] = 0;\n  let prefixEnd = 0;\n  let i = 1;\n  while (i < lps.length) {\n    if (pat[i] == pat[prefixEnd]) {\n      prefixEnd++;\n      lps[i] = prefixEnd;\n      i++;\n    } else if (prefixEnd === 0) {\n      lps[i] = 0;\n      i++;\n    } else {\n      prefixEnd = pat[prefixEnd - 1];\n    }\n  }\n  return lps;\n}\n\n/** Read delimited bytes from a Reader. */\nexport async function* readDelim(\n  reader: Reader,\n  delim: Uint8Array,\n): AsyncIterableIterator<Uint8Array> {\n  // Avoid unicode problems\n  const delimLen = delim.length;\n  const delimLPS = createLPS(delim);\n\n  let inputBuffer = new Deno.Buffer();\n  const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));\n\n  // Modified KMP\n  let inspectIndex = 0;\n  let matchIndex = 0;\n  while (true) {\n    const result = await reader.read(inspectArr);\n    if (result === null) {\n      // Yield last chunk.\n      yield inputBuffer.bytes();\n      return;\n    }\n    if ((result as number) < 0) {\n      // Discard all remaining and silently fail.\n      return;\n    }\n    const sliceRead = inspectArr.subarray(0, result as number);\n    await Deno.writeAll(inputBuffer, sliceRead);\n\n    let sliceToProcess = inputBuffer.bytes();\n    while (inspectIndex < sliceToProcess.length) {\n      if (sliceToProcess[inspectIndex] === delim[matchIndex]) {\n        inspectIndex++;\n        matchIndex++;\n        if (matchIndex === delimLen) {\n          // Full match\n          const matchEnd = inspectIndex - delimLen;\n          const readyBytes = sliceToProcess.subarray(0, matchEnd);\n          // Copy\n          const pendingBytes = sliceToProcess.slice(inspectIndex);\n          yield readyBytes;\n          // Reset match, different from KMP.\n          sliceToProcess = pendingBytes;\n          inspectIndex = 0;\n          matchIndex = 0;\n        }\n      } else {\n        if (matchIndex === 0) {\n          inspectIndex++;\n        } else {\n          matchIndex = delimLPS[matchIndex - 1];\n        }\n      }\n    }\n    // Keep inspectIndex and matchIndex.\n    inputBuffer = new Deno.Buffer(sliceToProcess);\n  }\n}\n\n/** Read delimited strings from a Reader. */\nexport async function* readStringDelim(\n  reader: Reader,\n  delim: string,\n): AsyncIterableIterator<string> {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  for await (const chunk of readDelim(reader, encoder.encode(delim))) {\n    yield decoder.decode(chunk);\n  }\n}\n\n/** Read strings line-by-line from a Reader. */\n// eslint-disable-next-line require-await\nexport async function* readLines(\n  reader: Reader,\n): AsyncIterableIterator<string> {\n  yield* readStringDelim(reader, \"\\n\");\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n// TODO(ry) It'd be better to make Deferred a class that inherits from\n// Promise, rather than an interface. This is possible in ES2016, however\n// typescript produces broken code when targeting ES5 code.\n// See https://github.com/Microsoft/TypeScript/issues/15202\n// At the time of writing, the github issue is closed but the problem remains.\nexport interface Deferred<T> extends Promise<T> {\n  resolve: (value?: T | PromiseLike<T>) => void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  reject: (reason?: any) => void;\n}\n\n/** Creates a Promise with the `reject` and `resolve` functions\n * placed as methods on the promise object itself. It allows you to do:\n *\n *     const p = deferred<number>();\n *     // ...\n *     p.resolve(42);\n */\nexport function deferred<T>(): Deferred<T> {\n  let methods;\n  const promise = new Promise<T>((resolve, reject): void => {\n    methods = { resolve, reject };\n  });\n  return Object.assign(promise, methods) as Deferred<T>;\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\nimport { Deferred, deferred } from \"./deferred.ts\";\n\ninterface TaggedYieldedValue<T> {\n  iterator: AsyncIterableIterator<T>;\n  value: T;\n}\n\n/** The MuxAsyncIterator class multiplexes multiple async iterators into a\n * single stream. It currently makes an assumption:\n * - The final result (the value returned and not yielded from the iterator)\n *   does not matter; if there is any, it is discarded.\n */\nexport class MuxAsyncIterator<T> implements AsyncIterable<T> {\n  private iteratorCount = 0;\n  private yields: Array<TaggedYieldedValue<T>> = [];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private throws: any[] = [];\n  private signal: Deferred<void> = deferred();\n\n  add(iterator: AsyncIterableIterator<T>): void {\n    ++this.iteratorCount;\n    this.callIteratorNext(iterator);\n  }\n\n  private async callIteratorNext(\n    iterator: AsyncIterableIterator<T>,\n  ): Promise<void> {\n    try {\n      const { value, done } = await iterator.next();\n      if (done) {\n        --this.iteratorCount;\n      } else {\n        this.yields.push({ iterator, value });\n      }\n    } catch (e) {\n      this.throws.push(e);\n    }\n    this.signal.resolve();\n  }\n\n  async *iterate(): AsyncIterableIterator<T> {\n    while (this.iteratorCount > 0) {\n      // Sleep until any of the wrapped iterators yields.\n      await this.signal;\n\n      // Note that while we're looping over `yields`, new items may be added.\n      for (let i = 0; i < this.yields.length; i++) {\n        const { iterator, value } = this.yields[i];\n        yield value;\n        this.callIteratorNext(iterator);\n      }\n\n      if (this.throws.length) {\n        for (const e of this.throws) {\n          throw e;\n        }\n        this.throws.length = 0;\n      }\n      // Clear the `yields` list and reset the `signal` promise.\n      this.yields.length = 0;\n      this.signal = deferred();\n    }\n  }\n\n  [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n    return this.iterate();\n  }\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n// Based on https://github.com/golang/go/tree/master/src/net/textproto\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\nimport type { BufReader } from \"../io/bufio.ts\";\nimport { concat } from \"../bytes/mod.ts\";\nimport { decode } from \"../encoding/utf8.ts\";\n\n// FROM https://github.com/denoland/deno/blob/b34628a26ab0187a827aa4ebe256e23178e25d39/cli/js/web/headers.ts#L9\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/g;\n\nfunction str(buf: Uint8Array | null | undefined): string {\n  if (buf == null) {\n    return \"\";\n  } else {\n    return decode(buf);\n  }\n}\n\nfunction charCode(s: string): number {\n  return s.charCodeAt(0);\n}\n\nexport class TextProtoReader {\n  constructor(readonly r: BufReader) {}\n\n  /** readLine() reads a single line from the TextProtoReader,\n   * eliding the final \\n or \\r\\n from the returned string.\n   */\n  async readLine(): Promise<string | null> {\n    const s = await this.readLineSlice();\n    if (s === null) return null;\n    return str(s);\n  }\n\n  /** ReadMIMEHeader reads a MIME-style header from r.\n   * The header is a sequence of possibly continued Key: Value lines\n   * ending in a blank line.\n   * The returned map m maps CanonicalMIMEHeaderKey(key) to a\n   * sequence of values in the same order encountered in the input.\n   *\n   * For example, consider this input:\n   *\n   *\tMy-Key: Value 1\n   *\tLong-Key: Even\n   *\t       Longer Value\n   *\tMy-Key: Value 2\n   *\n   * Given that input, ReadMIMEHeader returns the map:\n   *\n   *\tmap[string][]string{\n   *\t\t\"My-Key\": {\"Value 1\", \"Value 2\"},\n   *\t\t\"Long-Key\": {\"Even Longer Value\"},\n   *\t}\n   */\n  async readMIMEHeader(): Promise<Headers | null> {\n    const m = new Headers();\n    let line: Uint8Array | undefined;\n\n    // The first line cannot start with a leading space.\n    let buf = await this.r.peek(1);\n    if (buf === null) {\n      return null;\n    } else if (buf[0] == charCode(\" \") || buf[0] == charCode(\"\\t\")) {\n      line = (await this.readLineSlice()) as Uint8Array;\n    }\n\n    buf = await this.r.peek(1);\n    if (buf === null) {\n      throw new Deno.errors.UnexpectedEof();\n    } else if (buf[0] == charCode(\" \") || buf[0] == charCode(\"\\t\")) {\n      throw new Deno.errors.InvalidData(\n        `malformed MIME header initial line: ${str(line)}`,\n      );\n    }\n\n    while (true) {\n      const kv = await this.readLineSlice(); // readContinuedLineSlice\n      if (kv === null) throw new Deno.errors.UnexpectedEof();\n      if (kv.byteLength === 0) return m;\n\n      // Key ends at first colon\n      let i = kv.indexOf(charCode(\":\"));\n      if (i < 0) {\n        throw new Deno.errors.InvalidData(\n          `malformed MIME header line: ${str(kv)}`,\n        );\n      }\n\n      //let key = canonicalMIMEHeaderKey(kv.subarray(0, endKey));\n      const key = str(kv.subarray(0, i));\n\n      // As per RFC 7230 field-name is a token,\n      // tokens consist of one or more chars.\n      // We could throw `Deno.errors.InvalidData` here,\n      // but better to be liberal in what we\n      // accept, so if we get an empty key, skip it.\n      if (key == \"\") {\n        continue;\n      }\n\n      // Skip initial spaces in value.\n      i++; // skip colon\n      while (\n        i < kv.byteLength &&\n        (kv[i] == charCode(\" \") || kv[i] == charCode(\"\\t\"))\n      ) {\n        i++;\n      }\n      const value = str(kv.subarray(i)).replace(\n        invalidHeaderCharRegex,\n        encodeURI,\n      );\n\n      // In case of invalid header we swallow the error\n      // example: \"Audio Mode\" => invalid due to space in the key\n      try {\n        m.append(key, value);\n      } catch {\n        // Pass\n      }\n    }\n  }\n\n  async readLineSlice(): Promise<Uint8Array | null> {\n    // this.closeDot();\n    let line: Uint8Array | undefined;\n    while (true) {\n      const r = await this.r.readLine();\n      if (r === null) return null;\n      const { line: l, more } = r;\n\n      // Avoid the copy if the first call produced a full line.\n      if (!line && !more) {\n        // TODO(ry):\n        // This skipSpace() is definitely misplaced, but I don't know where it\n        // comes from nor how to fix it.\n        if (this.skipSpace(l) === 0) {\n          return new Uint8Array(0);\n        }\n        return l;\n      }\n      line = line ? concat(line, l) : l;\n      if (!more) {\n        break;\n      }\n    }\n    return line;\n  }\n\n  skipSpace(l: Uint8Array): number {\n    let n = 0;\n    for (let i = 0; i < l.length; i++) {\n      if (l[i] === charCode(\" \") || l[i] === charCode(\"\\t\")) {\n        continue;\n      }\n      n++;\n    }\n    return n;\n  }\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n\n/** HTTP status codes */\nexport enum Status {\n  /** RFC 7231, 6.2.1 */\n  Continue = 100,\n  /** RFC 7231, 6.2.2 */\n  SwitchingProtocols = 101,\n  /** RFC 2518, 10.1 */\n  Processing = 102,\n  /** RFC 8297 **/\n  EarlyHints = 103,\n  /** RFC 7231, 6.3.1 */\n  OK = 200,\n  /** RFC 7231, 6.3.2 */\n  Created = 201,\n  /** RFC 7231, 6.3.3 */\n  Accepted = 202,\n  /** RFC 7231, 6.3.4 */\n  NonAuthoritativeInfo = 203,\n  /** RFC 7231, 6.3.5 */\n  NoContent = 204,\n  /** RFC 7231, 6.3.6 */\n  ResetContent = 205,\n  /** RFC 7233, 4.1 */\n  PartialContent = 206,\n  /** RFC 4918, 11.1 */\n  MultiStatus = 207,\n  /** RFC 5842, 7.1 */\n  AlreadyReported = 208,\n  /** RFC 3229, 10.4.1 */\n  IMUsed = 226,\n\n  /** RFC 7231, 6.4.1 */\n  MultipleChoices = 300,\n  /** RFC 7231, 6.4.2 */\n  MovedPermanently = 301,\n  /** RFC 7231, 6.4.3 */\n  Found = 302,\n  /** RFC 7231, 6.4.4 */\n  SeeOther = 303,\n  /** RFC 7232, 4.1 */\n  NotModified = 304,\n  /** RFC 7231, 6.4.5 */\n  UseProxy = 305,\n  /** RFC 7231, 6.4.7 */\n  TemporaryRedirect = 307,\n  /** RFC 7538, 3 */\n  PermanentRedirect = 308,\n\n  /** RFC 7231, 6.5.1 */\n  BadRequest = 400,\n  /** RFC 7235, 3.1 */\n  Unauthorized = 401,\n  /** RFC 7231, 6.5.2 */\n  PaymentRequired = 402,\n  /** RFC 7231, 6.5.3 */\n  Forbidden = 403,\n  /** RFC 7231, 6.5.4 */\n  NotFound = 404,\n  /** RFC 7231, 6.5.5 */\n  MethodNotAllowed = 405,\n  /** RFC 7231, 6.5.6 */\n  NotAcceptable = 406,\n  /** RFC 7235, 3.2 */\n  ProxyAuthRequired = 407,\n  /** RFC 7231, 6.5.7 */\n  RequestTimeout = 408,\n  /** RFC 7231, 6.5.8 */\n  Conflict = 409,\n  /** RFC 7231, 6.5.9 */\n  Gone = 410,\n  /** RFC 7231, 6.5.10 */\n  LengthRequired = 411,\n  /** RFC 7232, 4.2 */\n  PreconditionFailed = 412,\n  /** RFC 7231, 6.5.11 */\n  RequestEntityTooLarge = 413,\n  /** RFC 7231, 6.5.12 */\n  RequestURITooLong = 414,\n  /** RFC 7231, 6.5.13 */\n  UnsupportedMediaType = 415,\n  /** RFC 7233, 4.4 */\n  RequestedRangeNotSatisfiable = 416,\n  /** RFC 7231, 6.5.14 */\n  ExpectationFailed = 417,\n  /** RFC 7168, 2.3.3 */\n  Teapot = 418,\n  /** RFC 7540, 9.1.2 */\n  MisdirectedRequest = 421,\n  /** RFC 4918, 11.2 */\n  UnprocessableEntity = 422,\n  /** RFC 4918, 11.3 */\n  Locked = 423,\n  /** RFC 4918, 11.4 */\n  FailedDependency = 424,\n  /** RFC 8470, 5.2 */\n  TooEarly = 425,\n  /** RFC 7231, 6.5.15 */\n  UpgradeRequired = 426,\n  /** RFC 6585, 3 */\n  PreconditionRequired = 428,\n  /** RFC 6585, 4 */\n  TooManyRequests = 429,\n  /** RFC 6585, 5 */\n  RequestHeaderFieldsTooLarge = 431,\n  /** RFC 7725, 3 */\n  UnavailableForLegalReasons = 451,\n\n  /** RFC 7231, 6.6.1 */\n  InternalServerError = 500,\n  /** RFC 7231, 6.6.2 */\n  NotImplemented = 501,\n  /** RFC 7231, 6.6.3 */\n  BadGateway = 502,\n  /** RFC 7231, 6.6.4 */\n  ServiceUnavailable = 503,\n  /** RFC 7231, 6.6.5 */\n  GatewayTimeout = 504,\n  /** RFC 7231, 6.6.6 */\n  HTTPVersionNotSupported = 505,\n  /** RFC 2295, 8.1 */\n  VariantAlsoNegotiates = 506,\n  /** RFC 4918, 11.5 */\n  InsufficientStorage = 507,\n  /** RFC 5842, 7.2 */\n  LoopDetected = 508,\n  /** RFC 2774, 7 */\n  NotExtended = 510,\n  /** RFC 6585, 6 */\n  NetworkAuthenticationRequired = 511,\n}\n\nexport const STATUS_TEXT = new Map<Status, string>([\n  [Status.Continue, \"Continue\"],\n  [Status.SwitchingProtocols, \"Switching Protocols\"],\n  [Status.Processing, \"Processing\"],\n  [Status.EarlyHints, \"Early Hints\"],\n  [Status.OK, \"OK\"],\n  [Status.Created, \"Created\"],\n  [Status.Accepted, \"Accepted\"],\n  [Status.NonAuthoritativeInfo, \"Non-Authoritative Information\"],\n  [Status.NoContent, \"No Content\"],\n  [Status.ResetContent, \"Reset Content\"],\n  [Status.PartialContent, \"Partial Content\"],\n  [Status.MultiStatus, \"Multi-Status\"],\n  [Status.AlreadyReported, \"Already Reported\"],\n  [Status.IMUsed, \"IM Used\"],\n  [Status.MultipleChoices, \"Multiple Choices\"],\n  [Status.MovedPermanently, \"Moved Permanently\"],\n  [Status.Found, \"Found\"],\n  [Status.SeeOther, \"See Other\"],\n  [Status.NotModified, \"Not Modified\"],\n  [Status.UseProxy, \"Use Proxy\"],\n  [Status.TemporaryRedirect, \"Temporary Redirect\"],\n  [Status.PermanentRedirect, \"Permanent Redirect\"],\n  [Status.BadRequest, \"Bad Request\"],\n  [Status.Unauthorized, \"Unauthorized\"],\n  [Status.PaymentRequired, \"Payment Required\"],\n  [Status.Forbidden, \"Forbidden\"],\n  [Status.NotFound, \"Not Found\"],\n  [Status.MethodNotAllowed, \"Method Not Allowed\"],\n  [Status.NotAcceptable, \"Not Acceptable\"],\n  [Status.ProxyAuthRequired, \"Proxy Authentication Required\"],\n  [Status.RequestTimeout, \"Request Timeout\"],\n  [Status.Conflict, \"Conflict\"],\n  [Status.Gone, \"Gone\"],\n  [Status.LengthRequired, \"Length Required\"],\n  [Status.PreconditionFailed, \"Precondition Failed\"],\n  [Status.RequestEntityTooLarge, \"Request Entity Too Large\"],\n  [Status.RequestURITooLong, \"Request URI Too Long\"],\n  [Status.UnsupportedMediaType, \"Unsupported Media Type\"],\n  [Status.RequestedRangeNotSatisfiable, \"Requested Range Not Satisfiable\"],\n  [Status.ExpectationFailed, \"Expectation Failed\"],\n  [Status.Teapot, \"I'm a teapot\"],\n  [Status.MisdirectedRequest, \"Misdirected Request\"],\n  [Status.UnprocessableEntity, \"Unprocessable Entity\"],\n  [Status.Locked, \"Locked\"],\n  [Status.FailedDependency, \"Failed Dependency\"],\n  [Status.TooEarly, \"Too Early\"],\n  [Status.UpgradeRequired, \"Upgrade Required\"],\n  [Status.PreconditionRequired, \"Precondition Required\"],\n  [Status.TooManyRequests, \"Too Many Requests\"],\n  [Status.RequestHeaderFieldsTooLarge, \"Request Header Fields Too Large\"],\n  [Status.UnavailableForLegalReasons, \"Unavailable For Legal Reasons\"],\n  [Status.InternalServerError, \"Internal Server Error\"],\n  [Status.NotImplemented, \"Not Implemented\"],\n  [Status.BadGateway, \"Bad Gateway\"],\n  [Status.ServiceUnavailable, \"Service Unavailable\"],\n  [Status.GatewayTimeout, \"Gateway Timeout\"],\n  [Status.HTTPVersionNotSupported, \"HTTP Version Not Supported\"],\n  [Status.VariantAlsoNegotiates, \"Variant Also Negotiates\"],\n  [Status.InsufficientStorage, \"Insufficient Storage\"],\n  [Status.LoopDetected, \"Loop Detected\"],\n  [Status.NotExtended, \"Not Extended\"],\n  [Status.NetworkAuthenticationRequired, \"Network Authentication Required\"],\n]);\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\nimport { BufReader, BufWriter } from \"../io/bufio.ts\";\nimport { TextProtoReader } from \"../textproto/mod.ts\";\nimport { assert } from \"../_util/assert.ts\";\nimport { encoder } from \"../encoding/utf8.ts\";\nimport { Response, ServerRequest } from \"./server.ts\";\nimport { STATUS_TEXT } from \"./http_status.ts\";\n\nexport function emptyReader(): Deno.Reader {\n  return {\n    read(_: Uint8Array): Promise<number | null> {\n      return Promise.resolve(null);\n    },\n  };\n}\n\nexport function bodyReader(contentLength: number, r: BufReader): Deno.Reader {\n  let totalRead = 0;\n  let finished = false;\n  async function read(buf: Uint8Array): Promise<number | null> {\n    if (finished) return null;\n    let result: number | null;\n    const remaining = contentLength - totalRead;\n    if (remaining >= buf.byteLength) {\n      result = await r.read(buf);\n    } else {\n      const readBuf = buf.subarray(0, remaining);\n      result = await r.read(readBuf);\n    }\n    if (result !== null) {\n      totalRead += result;\n    }\n    finished = totalRead === contentLength;\n    return result;\n  }\n  return { read };\n}\n\nexport function chunkedBodyReader(h: Headers, r: BufReader): Deno.Reader {\n  // Based on https://tools.ietf.org/html/rfc2616#section-19.4.6\n  const tp = new TextProtoReader(r);\n  let finished = false;\n  const chunks: Array<{\n    offset: number;\n    data: Uint8Array;\n  }> = [];\n  async function read(buf: Uint8Array): Promise<number | null> {\n    if (finished) return null;\n    const [chunk] = chunks;\n    if (chunk) {\n      const chunkRemaining = chunk.data.byteLength - chunk.offset;\n      const readLength = Math.min(chunkRemaining, buf.byteLength);\n      for (let i = 0; i < readLength; i++) {\n        buf[i] = chunk.data[chunk.offset + i];\n      }\n      chunk.offset += readLength;\n      if (chunk.offset === chunk.data.byteLength) {\n        chunks.shift();\n        // Consume \\r\\n;\n        if ((await tp.readLine()) === null) {\n          throw new Deno.errors.UnexpectedEof();\n        }\n      }\n      return readLength;\n    }\n    const line = await tp.readLine();\n    if (line === null) throw new Deno.errors.UnexpectedEof();\n    // TODO: handle chunk extension\n    const [chunkSizeString] = line.split(\";\");\n    const chunkSize = parseInt(chunkSizeString, 16);\n    if (Number.isNaN(chunkSize) || chunkSize < 0) {\n      throw new Error(\"Invalid chunk size\");\n    }\n    if (chunkSize > 0) {\n      if (chunkSize > buf.byteLength) {\n        let eof = await r.readFull(buf);\n        if (eof === null) {\n          throw new Deno.errors.UnexpectedEof();\n        }\n        const restChunk = new Uint8Array(chunkSize - buf.byteLength);\n        eof = await r.readFull(restChunk);\n        if (eof === null) {\n          throw new Deno.errors.UnexpectedEof();\n        } else {\n          chunks.push({\n            offset: 0,\n            data: restChunk,\n          });\n        }\n        return buf.byteLength;\n      } else {\n        const bufToFill = buf.subarray(0, chunkSize);\n        const eof = await r.readFull(bufToFill);\n        if (eof === null) {\n          throw new Deno.errors.UnexpectedEof();\n        }\n        // Consume \\r\\n\n        if ((await tp.readLine()) === null) {\n          throw new Deno.errors.UnexpectedEof();\n        }\n        return chunkSize;\n      }\n    } else {\n      assert(chunkSize === 0);\n      // Consume \\r\\n\n      if ((await r.readLine()) === null) {\n        throw new Deno.errors.UnexpectedEof();\n      }\n      await readTrailers(h, r);\n      finished = true;\n      return null;\n    }\n  }\n  return { read };\n}\n\nfunction isProhibidedForTrailer(key: string): boolean {\n  const s = new Set([\"transfer-encoding\", \"content-length\", \"trailer\"]);\n  return s.has(key.toLowerCase());\n}\n\n/** Read trailer headers from reader and append values to headers. \"trailer\"\n * field will be deleted. */\nexport async function readTrailers(\n  headers: Headers,\n  r: BufReader,\n): Promise<void> {\n  const trailers = parseTrailer(headers.get(\"trailer\"));\n  if (trailers == null) return;\n  const trailerNames = [...trailers.keys()];\n  const tp = new TextProtoReader(r);\n  const result = await tp.readMIMEHeader();\n  if (result == null) {\n    throw new Deno.errors.InvalidData(\"Missing trailer header.\");\n  }\n  const undeclared = [...result.keys()].filter(\n    (k) => !trailerNames.includes(k),\n  );\n  if (undeclared.length > 0) {\n    throw new Deno.errors.InvalidData(\n      `Undeclared trailers: ${Deno.inspect(undeclared)}.`,\n    );\n  }\n  for (const [k, v] of result) {\n    headers.append(k, v);\n  }\n  const missingTrailers = trailerNames.filter((k) => !result.has(k));\n  if (missingTrailers.length > 0) {\n    throw new Deno.errors.InvalidData(\n      `Missing trailers: ${Deno.inspect(missingTrailers)}.`,\n    );\n  }\n  headers.delete(\"trailer\");\n}\n\nfunction parseTrailer(field: string | null): Headers | undefined {\n  if (field == null) {\n    return undefined;\n  }\n  const trailerNames = field.split(\",\").map((v) => v.trim().toLowerCase());\n  if (trailerNames.length === 0) {\n    throw new Deno.errors.InvalidData(\"Empty trailer header.\");\n  }\n  const prohibited = trailerNames.filter((k) => isProhibidedForTrailer(k));\n  if (prohibited.length > 0) {\n    throw new Deno.errors.InvalidData(\n      `Prohibited trailer names: ${Deno.inspect(prohibited)}.`,\n    );\n  }\n  return new Headers(trailerNames.map((key) => [key, \"\"]));\n}\n\nexport async function writeChunkedBody(\n  w: Deno.Writer,\n  r: Deno.Reader,\n): Promise<void> {\n  const writer = BufWriter.create(w);\n  for await (const chunk of Deno.iter(r)) {\n    if (chunk.byteLength <= 0) continue;\n    const start = encoder.encode(`${chunk.byteLength.toString(16)}\\r\\n`);\n    const end = encoder.encode(\"\\r\\n\");\n    await writer.write(start);\n    await writer.write(chunk);\n    await writer.write(end);\n  }\n\n  const endChunk = encoder.encode(\"0\\r\\n\\r\\n\");\n  await writer.write(endChunk);\n}\n\n/** Write trailer headers to writer. It should mostly should be called after\n * `writeResponse()`. */\nexport async function writeTrailers(\n  w: Deno.Writer,\n  headers: Headers,\n  trailers: Headers,\n): Promise<void> {\n  const trailer = headers.get(\"trailer\");\n  if (trailer === null) {\n    throw new TypeError(\"Missing trailer header.\");\n  }\n  const transferEncoding = headers.get(\"transfer-encoding\");\n  if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {\n    throw new TypeError(\n      `Trailers are only allowed for \"transfer-encoding: chunked\", got \"transfer-encoding: ${transferEncoding}\".`,\n    );\n  }\n  const writer = BufWriter.create(w);\n  const trailerNames = trailer.split(\",\").map((s) => s.trim().toLowerCase());\n  const prohibitedTrailers = trailerNames.filter((k) =>\n    isProhibidedForTrailer(k)\n  );\n  if (prohibitedTrailers.length > 0) {\n    throw new TypeError(\n      `Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`,\n    );\n  }\n  const undeclared = [...trailers.keys()].filter(\n    (k) => !trailerNames.includes(k),\n  );\n  if (undeclared.length > 0) {\n    throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);\n  }\n  for (const [key, value] of trailers) {\n    await writer.write(encoder.encode(`${key}: ${value}\\r\\n`));\n  }\n  await writer.write(encoder.encode(\"\\r\\n\"));\n  await writer.flush();\n}\n\nexport async function writeResponse(\n  w: Deno.Writer,\n  r: Response,\n): Promise<void> {\n  const protoMajor = 1;\n  const protoMinor = 1;\n  const statusCode = r.status || 200;\n  const statusText = STATUS_TEXT.get(statusCode);\n  const writer = BufWriter.create(w);\n  if (!statusText) {\n    throw new Deno.errors.InvalidData(\"Bad status code\");\n  }\n  if (!r.body) {\n    r.body = new Uint8Array();\n  }\n  if (typeof r.body === \"string\") {\n    r.body = encoder.encode(r.body);\n  }\n\n  let out = `HTTP/${protoMajor}.${protoMinor} ${statusCode} ${statusText}\\r\\n`;\n\n  const headers = r.headers ?? new Headers();\n\n  if (r.body && !headers.get(\"content-length\")) {\n    if (r.body instanceof Uint8Array) {\n      out += `content-length: ${r.body.byteLength}\\r\\n`;\n    } else if (!headers.get(\"transfer-encoding\")) {\n      out += \"transfer-encoding: chunked\\r\\n\";\n    }\n  }\n\n  for (const [key, value] of headers) {\n    out += `${key}: ${value}\\r\\n`;\n  }\n\n  out += `\\r\\n`;\n\n  const header = encoder.encode(out);\n  const n = await writer.write(header);\n  assert(n === header.byteLength);\n\n  if (r.body instanceof Uint8Array) {\n    const n = await writer.write(r.body);\n    assert(n === r.body.byteLength);\n  } else if (headers.has(\"content-length\")) {\n    const contentLength = headers.get(\"content-length\");\n    assert(contentLength != null);\n    const bodyLength = parseInt(contentLength);\n    const n = await Deno.copy(r.body, writer);\n    assert(n === bodyLength);\n  } else {\n    await writeChunkedBody(writer, r.body);\n  }\n  if (r.trailers) {\n    const t = await r.trailers();\n    await writeTrailers(writer, headers, t);\n  }\n  await writer.flush();\n}\n\n/**\n * ParseHTTPVersion parses a HTTP version string.\n * \"HTTP/1.0\" returns (1, 0).\n * Ported from https://github.com/golang/go/blob/f5c43b9/src/net/http/request.go#L766-L792\n */\nexport function parseHTTPVersion(vers: string): [number, number] {\n  switch (vers) {\n    case \"HTTP/1.1\":\n      return [1, 1];\n\n    case \"HTTP/1.0\":\n      return [1, 0];\n\n    default: {\n      const Big = 1000000; // arbitrary upper bound\n\n      if (!vers.startsWith(\"HTTP/\")) {\n        break;\n      }\n\n      const dot = vers.indexOf(\".\");\n      if (dot < 0) {\n        break;\n      }\n\n      const majorStr = vers.substring(vers.indexOf(\"/\") + 1, dot);\n      const major = Number(majorStr);\n      if (!Number.isInteger(major) || major < 0 || major > Big) {\n        break;\n      }\n\n      const minorStr = vers.substring(dot + 1);\n      const minor = Number(minorStr);\n      if (!Number.isInteger(minor) || minor < 0 || minor > Big) {\n        break;\n      }\n\n      return [major, minor];\n    }\n  }\n\n  throw new Error(`malformed HTTP version ${vers}`);\n}\n\nexport async function readRequest(\n  conn: Deno.Conn,\n  bufr: BufReader,\n): Promise<ServerRequest | null> {\n  const tp = new TextProtoReader(bufr);\n  const firstLine = await tp.readLine(); // e.g. GET /index.html HTTP/1.0\n  if (firstLine === null) return null;\n  const headers = await tp.readMIMEHeader();\n  if (headers === null) throw new Deno.errors.UnexpectedEof();\n\n  const req = new ServerRequest();\n  req.conn = conn;\n  req.r = bufr;\n  [req.method, req.url, req.proto] = firstLine.split(\" \", 3);\n  [req.protoMinor, req.protoMajor] = parseHTTPVersion(req.proto);\n  req.headers = headers;\n  fixLength(req);\n  return req;\n}\n\nfunction fixLength(req: ServerRequest): void {\n  const contentLength = req.headers.get(\"Content-Length\");\n  if (contentLength) {\n    const arrClen = contentLength.split(\",\");\n    if (arrClen.length > 1) {\n      const distinct = [...new Set(arrClen.map((e): string => e.trim()))];\n      if (distinct.length > 1) {\n        throw Error(\"cannot contain multiple Content-Length headers\");\n      } else {\n        req.headers.set(\"Content-Length\", distinct[0]);\n      }\n    }\n    const c = req.headers.get(\"Content-Length\");\n    if (req.method === \"HEAD\" && c && c !== \"0\") {\n      throw Error(\"http: method cannot contain a Content-Length\");\n    }\n    if (c && req.headers.has(\"transfer-encoding\")) {\n      // A sender MUST NOT send a Content-Length header field in any message\n      // that contains a Transfer-Encoding header field.\n      // rfc: https://tools.ietf.org/html/rfc7230#section-3.3.2\n      throw new Error(\n        \"http: Transfer-Encoding and Content-Length cannot be send together\",\n      );\n    }\n  }\n}\n","// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\nimport { encode } from \"../encoding/utf8.ts\";\nimport { BufReader, BufWriter } from \"../io/bufio.ts\";\nimport { assert } from \"../_util/assert.ts\";\nimport { Deferred, deferred, MuxAsyncIterator } from \"../async/mod.ts\";\nimport {\n  bodyReader,\n  chunkedBodyReader,\n  emptyReader,\n  readRequest,\n  writeResponse,\n} from \"./_io.ts\";\n\nexport class ServerRequest {\n  url!: string;\n  method!: string;\n  proto!: string;\n  protoMinor!: number;\n  protoMajor!: number;\n  headers!: Headers;\n  conn!: Deno.Conn;\n  r!: BufReader;\n  w!: BufWriter;\n  done: Deferred<Error | undefined> = deferred();\n\n  private _contentLength: number | undefined | null = undefined;\n  /**\n   * Value of Content-Length header.\n   * If null, then content length is invalid or not given (e.g. chunked encoding).\n   */\n  get contentLength(): number | null {\n    // undefined means not cached.\n    // null means invalid or not provided.\n    if (this._contentLength === undefined) {\n      const cl = this.headers.get(\"content-length\");\n      if (cl) {\n        this._contentLength = parseInt(cl);\n        // Convert NaN to null (as NaN harder to test)\n        if (Number.isNaN(this._contentLength)) {\n          this._contentLength = null;\n        }\n      } else {\n        this._contentLength = null;\n      }\n    }\n    return this._contentLength;\n  }\n\n  private _body: Deno.Reader | null = null;\n\n  /**\n   * Body of the request.  The easiest way to consume the body is:\n   *\n   *     const buf: Uint8Array = await Deno.readAll(req.body);\n   */\n  get body(): Deno.Reader {\n    if (!this._body) {\n      if (this.contentLength != null) {\n        this._body = bodyReader(this.contentLength, this.r);\n      } else {\n        const transferEncoding = this.headers.get(\"transfer-encoding\");\n        if (transferEncoding != null) {\n          const parts = transferEncoding\n            .split(\",\")\n            .map((e): string => e.trim().toLowerCase());\n          assert(\n            parts.includes(\"chunked\"),\n            'transfer-encoding must include \"chunked\" if content-length is not set',\n          );\n          this._body = chunkedBodyReader(this.headers, this.r);\n        } else {\n          // Neither content-length nor transfer-encoding: chunked\n          this._body = emptyReader();\n        }\n      }\n    }\n    return this._body;\n  }\n\n  async respond(r: Response): Promise<void> {\n    let err: Error | undefined;\n    try {\n      // Write our response!\n      await writeResponse(this.w, r);\n    } catch (e) {\n      try {\n        // Eagerly close on error.\n        this.conn.close();\n      } catch {\n        // Pass\n      }\n      err = e;\n    }\n    // Signal that this request has been processed and the next pipelined\n    // request on the same connection can be accepted.\n    this.done.resolve(err);\n    if (err) {\n      // Error during responding, rethrow.\n      throw err;\n    }\n  }\n\n  private finalized = false;\n  async finalize(): Promise<void> {\n    if (this.finalized) return;\n    // Consume unread body\n    const body = this.body;\n    const buf = new Uint8Array(1024);\n    while ((await body.read(buf)) !== null) {\n      // Pass\n    }\n    this.finalized = true;\n  }\n}\n\nexport class Server implements AsyncIterable<ServerRequest> {\n  private closing = false;\n  private connections: Deno.Conn[] = [];\n\n  constructor(public listener: Deno.Listener) {}\n\n  close(): void {\n    this.closing = true;\n    this.listener.close();\n    for (const conn of this.connections) {\n      try {\n        conn.close();\n      } catch (e) {\n        // Connection might have been already closed\n        if (!(e instanceof Deno.errors.BadResource)) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Yields all HTTP requests on a single TCP connection.\n  private async *iterateHttpRequests(\n    conn: Deno.Conn,\n  ): AsyncIterableIterator<ServerRequest> {\n    const reader = new BufReader(conn);\n    const writer = new BufWriter(conn);\n\n    while (!this.closing) {\n      let request: ServerRequest | null;\n      try {\n        request = await readRequest(conn, reader);\n      } catch (error) {\n        if (\n          error instanceof Deno.errors.InvalidData ||\n          error instanceof Deno.errors.UnexpectedEof\n        ) {\n          // An error was thrown while parsing request headers.\n          await writeResponse(writer, {\n            status: 400,\n            body: encode(`${error.message}\\r\\n\\r\\n`),\n          });\n        }\n        break;\n      }\n      if (request === null) {\n        break;\n      }\n\n      request.w = writer;\n      yield request;\n\n      // Wait for the request to be processed before we accept a new request on\n      // this connection.\n      const responseError = await request.done;\n      if (responseError) {\n        // Something bad happened during response.\n        // (likely other side closed during pipelined req)\n        // req.done implies this connection already closed, so we can just return.\n        this.untrackConnection(request.conn);\n        return;\n      }\n      // Consume unread body and trailers if receiver didn't consume those data\n      await request.finalize();\n    }\n\n    this.untrackConnection(conn);\n    try {\n      conn.close();\n    } catch (e) {\n      // might have been already closed\n    }\n  }\n\n  private trackConnection(conn: Deno.Conn): void {\n    this.connections.push(conn);\n  }\n\n  private untrackConnection(conn: Deno.Conn): void {\n    const index = this.connections.indexOf(conn);\n    if (index !== -1) {\n      this.connections.splice(index, 1);\n    }\n  }\n\n  // Accepts a new TCP connection and yields all HTTP requests that arrive on\n  // it. When a connection is accepted, it also creates a new iterator of the\n  // same kind and adds it to the request multiplexer so that another TCP\n  // connection can be accepted.\n  private async *acceptConnAndIterateHttpRequests(\n    mux: MuxAsyncIterator<ServerRequest>,\n  ): AsyncIterableIterator<ServerRequest> {\n    if (this.closing) return;\n    // Wait for a new connection.\n    let conn: Deno.Conn;\n    try {\n      conn = await this.listener.accept();\n    } catch (error) {\n      if (\n        error instanceof Deno.errors.BadResource ||\n        error instanceof Deno.errors.InvalidData ||\n        error instanceof Deno.errors.UnexpectedEof\n      ) {\n        return mux.add(this.acceptConnAndIterateHttpRequests(mux));\n      }\n      throw error;\n    }\n    this.trackConnection(conn);\n    // Try to accept another connection and add it to the multiplexer.\n    mux.add(this.acceptConnAndIterateHttpRequests(mux));\n    // Yield the requests that arrive on the just-accepted connection.\n    yield* this.iterateHttpRequests(conn);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterableIterator<ServerRequest> {\n    const mux: MuxAsyncIterator<ServerRequest> = new MuxAsyncIterator();\n    mux.add(this.acceptConnAndIterateHttpRequests(mux));\n    return mux.iterate();\n  }\n}\n\n/** Options for creating an HTTP server. */\nexport type HTTPOptions = Omit<Deno.ListenOptions, \"transport\">;\n\n/**\n * Parse addr from string\n *\n *     const addr = \"::1:8000\";\n *     parseAddrFromString(addr);\n *\n * @param addr Address string\n */\nexport function _parseAddrFromStr(addr: string): HTTPOptions {\n  let url: URL;\n  try {\n    const host = addr.startsWith(\":\") ? `0.0.0.0${addr}` : addr;\n    url = new URL(`http://${host}`);\n  } catch {\n    throw new TypeError(\"Invalid address.\");\n  }\n  if (\n    url.username ||\n    url.password ||\n    url.pathname != \"/\" ||\n    url.search ||\n    url.hash\n  ) {\n    throw new TypeError(\"Invalid address.\");\n  }\n\n  return {\n    hostname: url.hostname,\n    port: url.port === \"\" ? 80 : Number(url.port),\n  };\n}\n\n/**\n * Create a HTTP server\n *\n *     import { serve } from \"https://deno.land/std/http/server.ts\";\n *     const body = \"Hello World\\n\";\n *     const server = serve({ port: 8000 });\n *     for await (const req of server) {\n *       req.respond({ body });\n *     }\n */\nexport function serve(addr: string | HTTPOptions): Server {\n  if (typeof addr === \"string\") {\n    addr = _parseAddrFromStr(addr);\n  }\n\n  const listener = Deno.listen(addr);\n  return new Server(listener);\n}\n\n/**\n * Start an HTTP server with given options and request handler\n *\n *     const body = \"Hello World\\n\";\n *     const options = { port: 8000 };\n *     listenAndServe(options, (req) => {\n *       req.respond({ body });\n *     });\n *\n * @param options Server configuration\n * @param handler Request handler\n */\nexport async function listenAndServe(\n  addr: string | HTTPOptions,\n  handler: (req: ServerRequest) => void,\n): Promise<void> {\n  const server = serve(addr);\n\n  for await (const request of server) {\n    handler(request);\n  }\n}\n\n/** Options for creating an HTTPS server. */\nexport type HTTPSOptions = Omit<Deno.ListenTlsOptions, \"transport\">;\n\n/**\n * Create an HTTPS server with given options\n *\n *     const body = \"Hello HTTPS\";\n *     const options = {\n *       hostname: \"localhost\",\n *       port: 443,\n *       certFile: \"./path/to/localhost.crt\",\n *       keyFile: \"./path/to/localhost.key\",\n *     };\n *     for await (const req of serveTLS(options)) {\n *       req.respond({ body });\n *     }\n *\n * @param options Server configuration\n * @return Async iterable server instance for incoming requests\n */\nexport function serveTLS(options: HTTPSOptions): Server {\n  const tlsOptions: Deno.ListenTlsOptions = {\n    ...options,\n    transport: \"tcp\",\n  };\n  const listener = Deno.listenTls(tlsOptions);\n  return new Server(listener);\n}\n\n/**\n * Start an HTTPS server with given options and request handler\n *\n *     const body = \"Hello HTTPS\";\n *     const options = {\n *       hostname: \"localhost\",\n *       port: 443,\n *       certFile: \"./path/to/localhost.crt\",\n *       keyFile: \"./path/to/localhost.key\",\n *     };\n *     listenAndServeTLS(options, (req) => {\n *       req.respond({ body });\n *     });\n *\n * @param options Server configuration\n * @param handler Request handler\n */\nexport async function listenAndServeTLS(\n  options: HTTPSOptions,\n  handler: (req: ServerRequest) => void,\n): Promise<void> {\n  const server = serveTLS(options);\n\n  for await (const request of server) {\n    handler(request);\n  }\n}\n\n/**\n * Interface of HTTP server response.\n * If body is a Reader, response would be chunked.\n * If body is a string, it would be UTF-8 encoded by default.\n */\nexport interface Response {\n  status?: number;\n  headers?: Headers;\n  body?: Uint8Array | Deno.Reader | string;\n  trailers?: () => Promise<Headers> | Headers;\n}\n","var exports = {},\n    _dewExec = false;\nexport function dew() {\n  if (_dewExec) return exports;\n  _dewExec = true;\n\n  exports = function eventify(subject) {\n    validateSubject(subject);\n    var eventsStorage = createEventsStorage(subject);\n    subject.on = eventsStorage.on;\n    subject.off = eventsStorage.off;\n    subject.fire = eventsStorage.fire;\n    return subject;\n  };\n\n  function createEventsStorage(subject) {\n    // Store all event listeners to this hash. Key is event name, value is array\n    // of callback records.\n    //\n    // A callback record consists of callback function and its optional context:\n    // { 'eventName' => [{callback: function, ctx: object}] }\n    var registeredEvents = Object.create(null);\n    return {\n      on: function (eventName, callback, ctx) {\n        if (typeof callback !== 'function') {\n          throw new Error('callback is expected to be a function');\n        }\n\n        var handlers = registeredEvents[eventName];\n\n        if (!handlers) {\n          handlers = registeredEvents[eventName] = [];\n        }\n\n        handlers.push({\n          callback: callback,\n          ctx: ctx\n        });\n        return subject;\n      },\n      off: function (eventName, callback) {\n        var wantToRemoveAll = typeof eventName === 'undefined';\n\n        if (wantToRemoveAll) {\n          // Killing old events storage should be enough in this case:\n          registeredEvents = Object.create(null);\n          return subject;\n        }\n\n        if (registeredEvents[eventName]) {\n          var deleteAllCallbacksForEvent = typeof callback !== 'function';\n\n          if (deleteAllCallbacksForEvent) {\n            delete registeredEvents[eventName];\n          } else {\n            var callbacks = registeredEvents[eventName];\n\n            for (var i = 0; i < callbacks.length; ++i) {\n              if (callbacks[i].callback === callback) {\n                callbacks.splice(i, 1);\n              }\n            }\n          }\n        }\n\n        return subject;\n      },\n      fire: function (eventName) {\n        var callbacks = registeredEvents[eventName];\n\n        if (!callbacks) {\n          return subject;\n        }\n\n        var fireArguments;\n\n        if (arguments.length > 1) {\n          fireArguments = Array.prototype.splice.call(arguments, 1);\n        }\n\n        for (var i = 0; i < callbacks.length; ++i) {\n          var callbackInfo = callbacks[i];\n          callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n        }\n\n        return subject;\n      }\n    };\n  }\n\n  function validateSubject(subject) {\n    if (!subject) {\n      throw new Error('Eventify cannot use falsy object as events subject');\n    }\n\n    var reservedWords = ['on', 'fire', 'off'];\n\n    for (var i = 0; i < reservedWords.length; ++i) {\n      if (subject.hasOwnProperty(reservedWords[i])) {\n        throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n      }\n    }\n  }\n\n  return exports;\n}","import { dew as _npmNgraphDew } from \"/npm:ngraph.events@1?dew\";\nvar exports = {},\n    _dewExec = false;\n\nvar _global = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : global;\n\nexport function dew() {\n  if (_dewExec) return exports;\n  _dewExec = true;\n\n  /**\n   * @fileOverview Contains definition of the core graph object.\n   */\n  // TODO: need to change storage layer:\n  // 1. Be able to get all nodes O(1)\n  // 2. Be able to get number of links O(1)\n\n  /**\n   * @example\n   *  var graph = require('ngraph.graph')();\n   *  graph.addNode(1);     // graph has one node.\n   *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n   *\n   */\n  exports = createGraph;\n\n  var eventify = _npmNgraphDew();\n  /**\n   * Creates a new graph\n   */\n\n\n  function createGraph(options) {\n    // Graph structure is maintained as dictionary of nodes\n    // and array of links. Each node has 'links' property which\n    // hold all links related to that node. And general links\n    // array is used to speed up all links enumeration. This is inefficient\n    // in terms of memory, but simplifies coding.\n    options = options || {};\n\n    if ('uniqueLinkId' in options) {\n      console.warn('ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\\n' + 'Use `multigraph` option instead\\n', '\\n', 'Note: there is also change in default behavior: From now on each graph\\n' + 'is considered to be not a multigraph by default (each edge is unique).');\n      options.multigraph = options.uniqueLinkId;\n    } // Dear reader, the non-multigraphs do not guarantee that there is only\n    // one link for a given pair of node. When this option is set to false\n    // we can save some memory and CPU (18% faster for non-multigraph);\n\n\n    if (options.multigraph === undefined) options.multigraph = false;\n\n    if (typeof Map !== 'function') {\n      // TODO: Should we polyfill it ourselves? We don't use much operations there..\n      throw new Error('ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph');\n    }\n\n    var nodes = new Map();\n    var links = [],\n        // Hash of multi-edges. Used to track ids of edges between same nodes\n    multiEdges = {},\n        suspendEvents = 0,\n        createLink = options.multigraph ? createUniqueLink : createSingleLink,\n        // Our graph API provides means to listen to graph changes. Users can subscribe\n    // to be notified about changes in the graph by using `on` method. However\n    // in some cases they don't use it. To avoid unnecessary memory consumption\n    // we will not record graph changes until we have at least one subscriber.\n    // Code below supports this optimization.\n    //\n    // Accumulates all changes made during graph updates.\n    // Each change element contains:\n    //  changeType - one of the strings: 'add', 'remove' or 'update';\n    //  node - if change is related to node this property is set to changed graph's node;\n    //  link - if change is related to link this property is set to changed graph's link;\n    changes = [],\n        recordLinkChange = noop,\n        recordNodeChange = noop,\n        enterModification = noop,\n        exitModification = noop; // this is our public API:\n\n    var graphPart = {\n      /**\n       * Adds node to the graph. If node with given id already exists in the graph\n       * its data is extended with whatever comes in 'data' argument.\n       *\n       * @param nodeId the node's identifier. A string or number is preferred.\n       * @param [data] additional data for the node being added. If node already\n       *   exists its data object is augmented with the new one.\n       *\n       * @return {node} The newly added node or node with given id if it already exists.\n       */\n      addNode: addNode,\n\n      /**\n       * Adds a link to the graph. The function always create a new\n       * link between two nodes. If one of the nodes does not exists\n       * a new node is created.\n       *\n       * @param fromId link start node id;\n       * @param toId link end node id;\n       * @param [data] additional data to be set on the new link;\n       *\n       * @return {link} The newly created link\n       */\n      addLink: addLink,\n\n      /**\n       * Removes link from the graph. If link does not exist does nothing.\n       *\n       * @param link - object returned by addLink() or getLinks() methods.\n       *\n       * @returns true if link was removed; false otherwise.\n       */\n      removeLink: removeLink,\n\n      /**\n       * Removes node with given id from the graph. If node does not exist in the graph\n       * does nothing.\n       *\n       * @param nodeId node's identifier passed to addNode() function.\n       *\n       * @returns true if node was removed; false otherwise.\n       */\n      removeNode: removeNode,\n\n      /**\n       * Gets node with given identifier. If node does not exist undefined value is returned.\n       *\n       * @param nodeId requested node identifier;\n       *\n       * @return {node} in with requested identifier or undefined if no such node exists.\n       */\n      getNode: getNode,\n\n      /**\n       * Gets number of nodes in this graph.\n       *\n       * @return number of nodes in the graph.\n       */\n      getNodeCount: getNodeCount,\n\n      /**\n       * Gets total number of links in the graph.\n       */\n      getLinkCount: getLinkCount,\n\n      /**\n       * Synonym for `getLinkCount()`\n       */\n      getLinksCount: getLinkCount,\n\n      /**\n       * Synonym for `getNodeCount()`\n       */\n      getNodesCount: getNodeCount,\n\n      /**\n       * Gets all links (inbound and outbound) from the node with given id.\n       * If node with given id is not found null is returned.\n       *\n       * @param nodeId requested node identifier.\n       *\n       * @return Array of links from and to requested node if such node exists;\n       *   otherwise null is returned.\n       */\n      getLinks: getLinks,\n\n      /**\n       * Invokes callback on each node of the graph.\n       *\n       * @param {Function(node)} callback Function to be invoked. The function\n       *   is passed one argument: visited node.\n       */\n      forEachNode: forEachNode,\n\n      /**\n       * Invokes callback on every linked (adjacent) node to the given one.\n       *\n       * @param nodeId Identifier of the requested node.\n       * @param {Function(node, link)} callback Function to be called on all linked nodes.\n       *   The function is passed two parameters: adjacent node and link object itself.\n       * @param oriented if true graph treated as oriented.\n       */\n      forEachLinkedNode: forEachLinkedNode,\n\n      /**\n       * Enumerates all links in the graph\n       *\n       * @param {Function(link)} callback Function to be called on all links in the graph.\n       *   The function is passed one parameter: graph's link object.\n       *\n       * Link object contains at least the following fields:\n       *  fromId - node id where link starts;\n       *  toId - node id where link ends,\n       *  data - additional data passed to graph.addLink() method.\n       */\n      forEachLink: forEachLink,\n\n      /**\n       * Suspend all notifications about graph changes until\n       * endUpdate is called.\n       */\n      beginUpdate: enterModification,\n\n      /**\n       * Resumes all notifications about graph changes and fires\n       * graph 'changed' event in case there are any pending changes.\n       */\n      endUpdate: exitModification,\n\n      /**\n       * Removes all nodes and links from the graph.\n       */\n      clear: clear,\n\n      /**\n       * Detects whether there is a link between two nodes.\n       * Operation complexity is O(n) where n - number of links of a node.\n       * NOTE: this function is synonim for getLink()\n       *\n       * @returns link if there is one. null otherwise.\n       */\n      hasLink: getLink,\n\n      /**\n       * Detects whether there is a node with given id\n       * \n       * Operation complexity is O(1)\n       * NOTE: this function is synonim for getNode()\n       *\n       * @returns node if there is one; Falsy value otherwise.\n       */\n      hasNode: getNode,\n\n      /**\n       * Gets an edge between two nodes.\n       * Operation complexity is O(n) where n - number of links of a node.\n       *\n       * @param {string} fromId link start identifier\n       * @param {string} toId link end identifier\n       *\n       * @returns link if there is one. null otherwise.\n       */\n      getLink: getLink\n    }; // this will add `on()` and `fire()` methods.\n\n    eventify(graphPart);\n    monitorSubscribers();\n    return graphPart;\n\n    function monitorSubscribers() {\n      var realOn = graphPart.on; // replace real `on` with our temporary on, which will trigger change\n      // modification monitoring:\n\n      graphPart.on = on;\n\n      function on() {\n        // now it's time to start tracking stuff:\n        graphPart.beginUpdate = enterModification = enterModificationReal;\n        graphPart.endUpdate = exitModification = exitModificationReal;\n        recordLinkChange = recordLinkChangeReal;\n        recordNodeChange = recordNodeChangeReal; // this will replace current `on` method with real pub/sub from `eventify`.\n\n        graphPart.on = realOn; // delegate to real `on` handler:\n\n        return realOn.apply(graphPart, arguments);\n      }\n    }\n\n    function recordLinkChangeReal(link, changeType) {\n      changes.push({\n        link: link,\n        changeType: changeType\n      });\n    }\n\n    function recordNodeChangeReal(node, changeType) {\n      changes.push({\n        node: node,\n        changeType: changeType\n      });\n    }\n\n    function addNode(nodeId, data) {\n      if (nodeId === undefined) {\n        throw new Error('Invalid node identifier');\n      }\n\n      enterModification();\n      var node = getNode(nodeId);\n\n      if (!node) {\n        node = new Node(nodeId, data);\n        recordNodeChange(node, 'add');\n      } else {\n        node.data = data;\n        recordNodeChange(node, 'update');\n      }\n\n      nodes.set(nodeId, node);\n      exitModification();\n      return node;\n    }\n\n    function getNode(nodeId) {\n      return nodes.get(nodeId);\n    }\n\n    function removeNode(nodeId) {\n      var node = getNode(nodeId);\n\n      if (!node) {\n        return false;\n      }\n\n      enterModification();\n      var prevLinks = node.links;\n\n      if (prevLinks) {\n        node.links = null;\n\n        for (var i = 0; i < prevLinks.length; ++i) {\n          removeLink(prevLinks[i]);\n        }\n      }\n\n      nodes.delete(nodeId);\n      recordNodeChange(node, 'remove');\n      exitModification();\n      return true;\n    }\n\n    function addLink(fromId, toId, data) {\n      enterModification();\n      var fromNode = getNode(fromId) || addNode(fromId);\n      var toNode = getNode(toId) || addNode(toId);\n      var link = createLink(fromId, toId, data);\n      links.push(link); // TODO: this is not cool. On large graphs potentially would consume more memory.\n\n      addLinkToNode(fromNode, link);\n\n      if (fromId !== toId) {\n        // make sure we are not duplicating links for self-loops\n        addLinkToNode(toNode, link);\n      }\n\n      recordLinkChange(link, 'add');\n      exitModification();\n      return link;\n    }\n\n    function createSingleLink(fromId, toId, data) {\n      var linkId = makeLinkId(fromId, toId);\n      return new Link(fromId, toId, data, linkId);\n    }\n\n    function createUniqueLink(fromId, toId, data) {\n      // TODO: Get rid of this method.\n      var linkId = makeLinkId(fromId, toId);\n      var isMultiEdge = multiEdges.hasOwnProperty(linkId);\n\n      if (isMultiEdge || getLink(fromId, toId)) {\n        if (!isMultiEdge) {\n          multiEdges[linkId] = 0;\n        }\n\n        var suffix = '@' + ++multiEdges[linkId];\n        linkId = makeLinkId(fromId + suffix, toId + suffix);\n      }\n\n      return new Link(fromId, toId, data, linkId);\n    }\n\n    function getNodeCount() {\n      return nodes.size;\n    }\n\n    function getLinkCount() {\n      return links.length;\n    }\n\n    function getLinks(nodeId) {\n      var node = getNode(nodeId);\n      return node ? node.links : null;\n    }\n\n    function removeLink(link) {\n      if (!link) {\n        return false;\n      }\n\n      var idx = indexOfElementInArray(link, links);\n\n      if (idx < 0) {\n        return false;\n      }\n\n      enterModification();\n      links.splice(idx, 1);\n      var fromNode = getNode(link.fromId);\n      var toNode = getNode(link.toId);\n\n      if (fromNode) {\n        idx = indexOfElementInArray(link, fromNode.links);\n\n        if (idx >= 0) {\n          fromNode.links.splice(idx, 1);\n        }\n      }\n\n      if (toNode) {\n        idx = indexOfElementInArray(link, toNode.links);\n\n        if (idx >= 0) {\n          toNode.links.splice(idx, 1);\n        }\n      }\n\n      recordLinkChange(link, 'remove');\n      exitModification();\n      return true;\n    }\n\n    function getLink(fromNodeId, toNodeId) {\n      // TODO: Use sorted links to speed this up\n      var node = getNode(fromNodeId),\n          i;\n\n      if (!node || !node.links) {\n        return null;\n      }\n\n      for (i = 0; i < node.links.length; ++i) {\n        var link = node.links[i];\n\n        if (link.fromId === fromNodeId && link.toId === toNodeId) {\n          return link;\n        }\n      }\n\n      return null; // no link.\n    }\n\n    function clear() {\n      enterModification();\n      forEachNode(function (node) {\n        removeNode(node.id);\n      });\n      exitModification();\n    }\n\n    function forEachLink(callback) {\n      var i, length;\n\n      if (typeof callback === 'function') {\n        for (i = 0, length = links.length; i < length; ++i) {\n          callback(links[i]);\n        }\n      }\n    }\n\n    function forEachLinkedNode(nodeId, callback, oriented) {\n      var node = getNode(nodeId);\n\n      if (node && node.links && typeof callback === 'function') {\n        if (oriented) {\n          return forEachOrientedLink(node.links, nodeId, callback);\n        } else {\n          return forEachNonOrientedLink(node.links, nodeId, callback);\n        }\n      }\n    }\n\n    function forEachNonOrientedLink(links, nodeId, callback) {\n      var quitFast;\n\n      for (var i = 0; i < links.length; ++i) {\n        var link = links[i];\n        var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n        quitFast = callback(nodes.get(linkedNodeId), link);\n\n        if (quitFast) {\n          return true; // Client does not need more iterations. Break now.\n        }\n      }\n    }\n\n    function forEachOrientedLink(links, nodeId, callback) {\n      var quitFast;\n\n      for (var i = 0; i < links.length; ++i) {\n        var link = links[i];\n\n        if (link.fromId === nodeId) {\n          quitFast = callback(nodes.get(link.toId), link);\n\n          if (quitFast) {\n            return true; // Client does not need more iterations. Break now.\n          }\n        }\n      }\n    } // we will not fire anything until users of this library explicitly call `on()`\n    // method.\n\n\n    function noop() {} // Enter, Exit modification allows bulk graph updates without firing events.\n\n\n    function enterModificationReal() {\n      suspendEvents += 1;\n    }\n\n    function exitModificationReal() {\n      suspendEvents -= 1;\n\n      if (suspendEvents === 0 && changes.length > 0) {\n        graphPart.fire('changed', changes);\n        changes.length = 0;\n      }\n    }\n\n    function forEachNode(callback) {\n      if (typeof callback !== 'function') {\n        throw new Error('Function is expected to iterate over graph nodes. You passed ' + callback);\n      }\n\n      var valuesIterator = nodes.values();\n      var nextValue = valuesIterator.next();\n\n      while (!nextValue.done) {\n        if (callback(nextValue.value)) {\n          return true; // client doesn't want to proceed. Return.\n        }\n\n        nextValue = valuesIterator.next();\n      }\n    }\n  } // need this for old browsers. Should this be a separate module?\n\n\n  function indexOfElementInArray(element, array) {\n    if (!array) return -1;\n\n    if (array.indexOf) {\n      return array.indexOf(element);\n    }\n\n    var len = array.length,\n        i;\n\n    for (i = 0; i < len; i += 1) {\n      if (array[i] === element) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Internal structure to represent node;\n   */\n\n\n  function Node(id, data) {\n    (this || _global).id = id;\n    (this || _global).links = null;\n    (this || _global).data = data;\n  }\n\n  function addLinkToNode(node, link) {\n    if (node.links) {\n      node.links.push(link);\n    } else {\n      node.links = [link];\n    }\n  }\n  /**\n   * Internal structure to represent links;\n   */\n\n\n  function Link(fromId, toId, data, id) {\n    (this || _global).fromId = fromId;\n    (this || _global).toId = toId;\n    (this || _global).data = data;\n    (this || _global).id = id;\n  }\n\n  function makeLinkId(fromId, toId) {\n    return fromId.toString() + ' ' + toId.toString();\n  }\n\n  return exports;\n}","import { dew } from \"/npm:ngraph.graph@19.1.0/index.dew.js\";\nexport default dew();\nimport \"/npm:ngraph.events@1?dew\";\n","// Copyright 2020 Janos Veres. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\nimport { Status } from \"https://deno.land/std@0.74.0/http/http_status.ts\";\nimport createGraph from \"https://dev.jspm.io/ngraph.graph\";\n\nlet fetchHeader = {}; // fixes Deno's HTTP_PROXY auth issue\nconst httpProxy = Deno.env.get(\"HTTP_PROXY\");\nif (httpProxy) {\n  const url = new URL(httpProxy);\n  fetchHeader = {\n    headers: {\n      \"Authorization\": `Basic ${btoa(url.username + \":\" + url.password)}`,\n    },\n  };\n  console.info(\n    `Using HTTP_PROXY (origin=\"${url.origin}\", Authorization=\"Basic ***...***\")`,\n  );\n}\n\nexport interface EgoGraphOptions {\n  query: string;\n  pattern?: string;\n  depth?: number;\n  radius?: number;\n}\n\nexport class EgoGraph {\n  static readonly DEFAULT_GRAPH_DEPTH: number = 1;\n  static readonly DEFAULT_SEARCH_PATTERN: string = \" vs \";\n  static readonly DEFAULT_GRAPH_RADIUS: number = 10;\n\n  private readonly query: string;\n  private readonly pattern: string;\n  private readonly depth: number;\n  private readonly radius: number;\n\n  public readonly graph: any;\n\n  private elapsedMs: number = 0;\n  private maxDistance: number = Number.NEGATIVE_INFINITY;\n\n  /**\n   * Creates a new EgoGraph instance.\n   * @constructor\n   * @param {EgoGraphOptions} options - Options for creating the ego network.\n   */\n  constructor(options: EgoGraphOptions = { query: \"\" }) {\n    this.graph = (createGraph as () => any)();\n    this.query = options.query;\n    this.depth = options.depth ?? EgoGraph.DEFAULT_GRAPH_DEPTH;\n    this.pattern = options.pattern ?? EgoGraph.DEFAULT_SEARCH_PATTERN;\n    this.radius = options.radius ?? EgoGraph.DEFAULT_GRAPH_RADIUS;\n  }\n\n  private async fetchAutocomplete(\n    term: string,\n    maxCount: number,\n  ): Promise<Set<string>> {\n    const q = term + this.pattern;\n    const res = await fetch(\n      `http://suggestqueries.google.com/complete/search?&client=firefox&gl=us&hl=en&q=${\n        encodeURIComponent(q)\n      }`,\n      fetchHeader,\n    );\n    if (res.status === Status.OK) {\n      const hits = await res.json();\n      const set = new Set<string>();\n      for (let hit of hits[1].slice(0, maxCount)) {\n        hit.split(this.pattern).slice(1).map((t: string) => {\n          if (!new RegExp(\"^[0-9.]+$\").test(t)) { // filters\n            set.add(t);\n          }\n        });\n      }\n      return set;\n    } else {\n      throw new Error(`${res.status} ${res.statusText}`);\n    }\n  }\n\n  /**\n   * Builds the graph.\n   * @returns {void}\n   */\n  async build() {\n    if (this.query === \"\") return;\n    const t1 = performance.now();\n    this.graph.beginUpdate();\n    let sources: string[] = [this.query];\n    let distances: number[] = [0];\n    for (let depth = 0; depth < this.depth; depth++) {\n      let nextSources: string[] = [];\n      let nextDistances: number[] = [];\n      for (let i = 0; i < sources.length; i++) {\n        const srcDistance = distances[i];\n        if (srcDistance >= this.radius) continue;\n        const src = sources[i];\n        const targets = await this.fetchAutocomplete(\n          src,\n          this.radius - srcDistance,\n        );\n        if (!this.graph.getNode(src)) {\n          this.graph.addNode(src, {\n            count: 1,\n            depth: src === this.query ? 0 : depth + 1,\n          }); // new node\n        }\n        let weight: number = targets.size;\n        let distance = 1;\n        targets.forEach((target: string) => {\n          const dist = srcDistance + distance;\n          if (dist > this.maxDistance) this.maxDistance = dist;\n          const targetNode = this.graph.getNode(target);\n          if (!targetNode) {\n            this.graph.addNode(target, { count: 1, depth: depth + 1 });\n            this.graph.addLink(\n              src,\n              target,\n              {\n                distance: dist,\n                weight,\n                query: `${src}${this.pattern}${target}`,\n              },\n            ); // new edge\n            nextDistances.push(dist);\n            nextSources.push(target);\n          } else {\n            targetNode.data.count++; // existing node\n            const link1 = this.graph.getLink(src, target),\n              link2 = this.graph.getLink(target, src);\n            if (link1 || link2) {\n              link1 ? link1.data.weight += weight : link2.data.weight += weight;\n            } else {\n              this.graph.addLink(\n                src,\n                target,\n                {\n                  distance: dist,\n                  weight,\n                  query: `${src}${this.pattern}${target}`,\n                },\n              ); // existing edge\n            }\n          }\n          weight -= 1;\n          distance += 1;\n        });\n      }\n      sources = nextSources;\n      distances = nextDistances;\n    }\n    this.graph.endUpdate();\n    this.elapsedMs = performance.now() - t1;\n    console.log(`build() took ${this.elapsedMs}ms`);\n  }\n\n  /**\n   * Creates final object representation of the graph. Should be called after build().\n   * @returns {object} {nodes: [...], links: [...], query, depth, radius, maxWeight, maxDistance, pattern, elapsedMs}\n   */\n  toObject() {\n    let maxWeight = Number.NEGATIVE_INFINITY;\n    this.graph.forEachLink((link: any) => {\n      if (link.data.weight > maxWeight) maxWeight = link.data.weight;\n    });\n    const json = {\n      nodes: [] as any,\n      links: [] as any,\n      query: this.query,\n      depth: this.depth,\n      radius: this.radius,\n      maxWeight,\n      maxDistance: this.maxDistance,\n      pattern: this.pattern,\n      elapsedMs: this.elapsedMs,\n    };\n    this.graph.forEachNode((node: any) => {\n      json.nodes.push({ id: node.id, ...node.data });\n    });\n    this.graph.forEachLink((link: any) => {\n      json.links.push({ source: link.fromId, target: link.toId, ...link.data });\n    });\n    return json;\n  }\n}\n","// Copyright 2020 Janos Veres. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\nimport {\n  serve,\n  ServerRequest,\n} from \"https://deno.land/std@0.74.0/http/server.ts\";\nimport { Status } from \"https://deno.land/std@0.74.0/http/http_status.ts\";\nimport { EgoGraph, EgoGraphOptions } from \"./egograph.ts\";\n\nconst SERVER_HOST = \"0.0.0.0\";\nconst SERVER_PORT = Deno.env.get(\"PORT\") ?? \"8080\";\nconst ALLOWED_ORIGINS = [\"https://ego.jveres.me\"];\nconst MAX_CACHE_CAPACITY = 500;\nconst CACHE_EXPIRATION_MS = 3 * 60 * 60 * 1000; // 3 hours\n\ninterface Cache {\n  date: number;\n  value: string;\n}\n\nconst httpCache = new Map<string, Cache>();\nconst responseHeaders = new Headers();\n\nconst handleQuery = async (\n  req: ServerRequest,\n  options: EgoGraphOptions,\n): Promise<void> => {\n  console.log(`${req.method} ${req.url}`);\n  const cacheKey = `${options.query}#${options.depth ??\n    EgoGraph.DEFAULT_GRAPH_DEPTH}#${options.pattern ??\n    EgoGraph.DEFAULT_SEARCH_PATTERN}#${options.radius ??\n    EgoGraph.DEFAULT_GRAPH_RADIUS}`;\n  let cache = httpCache.get(cacheKey);\n  if (!(cache && (Date.now() - cache.date) < CACHE_EXPIRATION_MS)) { // not found in cache or expired\n    const ego = new EgoGraph(\n      { query: options.query, depth: options.depth, radius: options.radius },\n    );\n    await ego.build();\n    console.info(\n      `${req.method} ${req.url} ${\n        cache ? \"Refreshed in cache\" : \"Cached\"\n      } at ${httpCache.size}`,\n    );\n    cache = { date: Date.now(), value: JSON.stringify(ego.toObject()) };\n    httpCache.set(cacheKey, cache);\n    if (httpCache.size > MAX_CACHE_CAPACITY) {\n      httpCache.delete(httpCache.keys().next().value); // rotate cache\n    }\n    responseHeaders.set(\"fly-cache-status\", \"MISS\");\n  } else {\n    console.info(`${req.method} ${req.url} Found in cache`);\n    responseHeaders.set(\"fly-cache-status\", \"HIT\");\n  }\n  return req.respond({\n    status: Status.OK,\n    headers: responseHeaders,\n    body: cache.value,\n  });\n};\n\nconst handleNotAcceptable = async (\n  req: ServerRequest,\n): Promise<void> => {\n  console.error(`${req.method} ${req.url} Not acceptable`);\n  return req.respond({\n    status: Status.NotAcceptable,\n    headers: responseHeaders,\n    body: JSON.stringify({\n      message: \"Not acceptable\",\n    }),\n  });\n};\n\nconst handleNotFound = async (req: ServerRequest): Promise<void> => {\n  console.warn(`${req.method} ${req.url} Not Found`);\n  return req.respond({\n    status: Status.NotFound,\n    headers: responseHeaders,\n    body: JSON.stringify({\n      message: \"Request not found\",\n    }),\n  });\n};\n\nconst handleError = async (\n  req: ServerRequest,\n  message: string,\n): Promise<void> => {\n  console.error(`${req.method} ${req.url} ${message}`);\n  return req.respond({\n    status: Status.InternalServerError,\n    headers: responseHeaders,\n    body: JSON.stringify({\n      message: \"Internal server error\",\n      error: message,\n    }),\n  });\n};\n\nconst server = serve({ hostname: SERVER_HOST, port: Number(SERVER_PORT) });\nconsole.log(`Server is running at ${SERVER_HOST}:${SERVER_PORT}`);\nconsole.log(`Redis is accessible at ${Deno.env.get(\"FLY_REDIS_CACHE_URL\")}`);\n\n(async () => {\n  for await (const req of server) {\n    const origin = req.headers.get(\"origin\");\n    if (origin && ALLOWED_ORIGINS.indexOf(origin) !== -1) {\n      responseHeaders.set(\"Access-Control-Allow-Origin\", origin); // enable CORS\n    }\n    const host = req.headers.get(\"host\");\n    const params = new URLSearchParams(req.url.slice(1));\n    if (\n      host !== `localhost:${SERVER_PORT}` &&\n      !responseHeaders.get(\"Access-Control-Allow-Origin\")\n    ) {\n      handleNotAcceptable(req); // not local dev and missing or not allowed origin\n    } else if (req.method === \"GET\" && params.get(\"q\")) {\n      handleQuery(req, {\n        query: params.get(\"q\") ?? \"\",\n        ...params.get(\"d\") && { depth: Number(params.get(\"d\")) },\n        ...params.get(\"r\") && { radius: Number(params.get(\"r\")) },\n      })\n        .catch(async ({ message }) => {\n          try {\n            await handleError(req, message);\n          } catch (err) {\n            console.error(err); // Issue with broken pipe (os error 32)\n          }\n        });\n    } else {\n      handleNotFound(req);\n    }\n  }\n})(); // denopack doesn't support top-level await yet\n"],"names":["encoder","TextEncoder","decoder","TextDecoder","concat","origin","b","output","Uint8Array","length","set","copyBytes","src","dst","off","Math","max","min","byteLength","dstBytesAvailable","subarray","DenoStdInternalError","Error","[object Object]","message","super","this","name","assert","expr","msg","CR","charCodeAt","LF","BufferFullError","partial","PartialReadError","Deno","errors","UnexpectedEof","BufReader","rd","size","_reset","r","buf","w","copyWithin","i","rr","read","eof","p","copied","bytesRead","err","_fill","c","delim","buffer","readSlice","decode","line","more","drop","slice","s","indexOf","buffered","oldbuf","newbuf","n","avail","BufWriter","usedBufferBytes","writer","writeAll","e","data","totalBytesWritten","numBytesWritten","available","write","flush","deferred","methods","promise","Promise","resolve","reject","Object","assign","MuxAsyncIterator","iterator","iteratorCount","callIteratorNext","value","done","next","yields","push","throws","signal","Symbol","asyncIterator","iterate","invalidHeaderCharRegex","str","input","charCode","TextProtoReader","readLineSlice","m","Headers","peek","InvalidData","kv","key","replace","encodeURI","append","readLine","l","skipSpace","Status","STATUS_TEXT","Map","Continue","SwitchingProtocols","Processing","EarlyHints","OK","Created","Accepted","NonAuthoritativeInfo","NoContent","ResetContent","PartialContent","MultiStatus","AlreadyReported","IMUsed","MultipleChoices","MovedPermanently","Found","SeeOther","NotModified","UseProxy","TemporaryRedirect","PermanentRedirect","BadRequest","Unauthorized","PaymentRequired","Forbidden","NotFound","MethodNotAllowed","NotAcceptable","ProxyAuthRequired","RequestTimeout","Conflict","Gone","LengthRequired","PreconditionFailed","RequestEntityTooLarge","RequestURITooLong","UnsupportedMediaType","RequestedRangeNotSatisfiable","ExpectationFailed","Teapot","MisdirectedRequest","UnprocessableEntity","Locked","FailedDependency","TooEarly","UpgradeRequired","PreconditionRequired","TooManyRequests","RequestHeaderFieldsTooLarge","UnavailableForLegalReasons","InternalServerError","NotImplemented","BadGateway","ServiceUnavailable","GatewayTimeout","HTTPVersionNotSupported","VariantAlsoNegotiates","InsufficientStorage","LoopDetected","NotExtended","NetworkAuthenticationRequired","chunkedBodyReader","h","tp","finished","chunks","async","chunk","chunkRemaining","offset","readLength","shift","chunkSizeString","split","chunkSize","parseInt","Number","isNaN","readFull","restChunk","bufToFill","headers","trailers","field","trailerNames","map","v","trim","toLowerCase","prohibited","filter","k","isProhibidedForTrailer","inspect","parseTrailer","get","keys","result","readMIMEHeader","undeclared","includes","missingTrailers","has","delete","readTrailers","Set","writeResponse","statusCode","status","statusText","create","body","encode","out","header","contentLength","bodyLength","copy","iter","start","toString","end","endChunk","writeChunkedBody","t","trailer","TypeError","transferEncoding","match","prohibitedTrailers","writeTrailers","readRequest","conn","bufr","firstLine","req","ServerRequest","method","url","proto","protoMinor","protoMajor","vers","Big","startsWith","dot","majorStr","substring","major","isInteger","minorStr","minor","parseHTTPVersion","arrClen","distinct","fixLength","undefined","_contentLength","cl","_body","totalRead","remaining","readBuf","bodyReader","_","close","finalized","Server","listener","closing","connections","BadResource","reader","request","error","untrackConnection","finalize","index","splice","mux","accept","add","acceptConnAndIterateHttpRequests","trackConnection","iterateHttpRequests","exports","_dewExec","dew","subject","reservedWords","hasOwnProperty","validateSubject","eventsStorage","registeredEvents","on","eventName","callback","ctx","handlers","callbacks","fire","fireArguments","arguments","Array","prototype","call","callbackInfo","apply","createEventsStorage","_global","globalThis","self","global","options","console","warn","multigraph","uniqueLinkId","nodes","links","multiEdges","suspendEvents","createLink","fromId","toId","linkId","makeLinkId","isMultiEdge","getLink","suffix","Link","changes","recordLinkChange","noop","recordNodeChange","enterModification","exitModification","graphPart","addNode","addLink","fromNode","getNode","toNode","link","addLinkToNode","removeLink","removeNode","getNodeCount","getLinkCount","getLinksCount","getNodesCount","getLinks","nodeId","node","forEachNode","forEachLinkedNode","oriented","forEachOrientedLink","linkedNodeId","forEachNonOrientedLink","forEachLink","beginUpdate","endUpdate","clear","id","hasLink","hasNode","eventify","realOn","enterModificationReal","exitModificationReal","recordLinkChangeReal","recordNodeChangeReal","monitorSubscribers","changeType","Node","prevLinks","idx","indexOfElementInArray","fromNodeId","toNodeId","valuesIterator","values","nextValue","_npmNgraphDew","element","array","len","fetchHeader","httpProxy","env","URL","Authorization","btoa","username","password","info","EgoGraph","query","NEGATIVE_INFINITY","graph","createGraph","depth","DEFAULT_GRAPH_DEPTH","pattern","DEFAULT_SEARCH_PATTERN","radius","DEFAULT_GRAPH_RADIUS","term","maxCount","q","res","fetch","encodeURIComponent","hits","json","hit","RegExp","test","t1","performance","now","sources","distances","nextSources","nextDistances","srcDistance","targets","fetchAutocomplete","count","weight","distance","forEach","target","dist","maxDistance","targetNode","link1","link2","elapsedMs","log","maxWeight","source","SERVER_PORT","ALLOWED_ORIGINS","httpCache","responseHeaders","handleQuery","cacheKey","cache","Date","date","ego","build","JSON","stringify","toObject","respond","handleNotAcceptable","handleNotFound","handleError","server","addr","host","pathname","search","hash","hostname","port","_parseAddrFromStr","listen","serve","params","URLSearchParams","catch"],"mappings":"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"}